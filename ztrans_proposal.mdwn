# Zftrans - transcendental operations

See:

* <http://bugs.libre-riscv.org/show_bug.cgi?id=127>
* <https://www.khronos.org/registry/spir-v/specs/unified1/OpenCL.ExtendedInstructionSet.100.html>
* Discussion: <http://lists.libre-riscv.org/pipermail/libre-riscv-dev/2019-August/002342.html>
* [[rv_major_opcode_1010011]] for opcode listing.
* [[zfpacc_proposal]] for accuracy settings proposal

Extension subsets:

* **Zftrans**: standard transcendentals (best suited to 3D)
* **ZftransExt**: extra functions (useful, not generally needed for 3D,
  can be synthesised using Ztrans)
* **Ztrigpi**: trig. xxx-pi sinpi cospi tanpi
* **Ztrignpi**: trig non-xxx-pi sin cos tan
* **Zarctrigpi**: arc-trig. a-xxx-pi: atan2pi asinpi acospi
* **Zarctrignpi**: arc-trig. non-a-xxx-pi: atan2, asin, acos
* **Zfhyp**: hyperbolic/inverse-hyperbolic.  sinh, cosh, tanh, asinh,
  acosh, atanh (can be synthesised - see below)
* **ZftransAdv**: much more complex to implement in hardware
* **Zfrsqrt**: Reciprocal square-root.

Minimum recommended requirements for 3D: Zftrans, Ztrigpi, Zarctrigpi,
Zarctrignpi

[[!toc levels=2]]

# TODO:

* Decision on accuracy, moved to [[zfpacc_proposal]]
<http://lists.libre-riscv.org/pipermail/libre-riscv-dev/2019-August/002355.html>
* Errors **MUST** be repeatable.
* How about four Platform Specifications? 3DUNIX, UNIX, 3DEmbedded and Embedded?
<http://lists.libre-riscv.org/pipermail/libre-riscv-dev/2019-August/002361.html>
  Accuracy requirements for dual (triple) purpose implementations must
  meet the higher standard.
* Reciprocal Square-root is in its own separate extension (Zfrsqrt) as
  it is desirable on its own by other implementors.  This to be evaluated.

# Proposed Opcodes vs Khronos OpenCL Opcodes <a name="khronos_equiv"></a>

This list shows the (direct) equivalence between proposed opcodes and
their Khronos OpenCL equivalents.

See
<https://www.khronos.org/registry/spir-v/specs/unified1/OpenCL.ExtendedInstructionSet.100.html>

Special FP16 opcodes are *not* being proposed, except by indirect / inherent
use of the "fmt" field that is already present in the RISC-V Specification.

"Native" opcodes are *not* being proposed: implementors will be expected
to use the (equivalent) proposed opcode covering the same function.

"Fast" opcodes are *not* being proposed, because the Khronos Specification
fast\_length, fast\_normalise and fast\_distance OpenCL opcodes require
vectors (or can be done as scalar operations using other RISC-V instructions).

The OpenCL FP32 opcodes are **direct** equivalents to the proposed opcodes.
Deviation from conformance with the Khronos Specification - including the
Khronos Specification accuracy requirements - is not an option.

[[!table data="""
Proposed opcode | OpenCL FP32 | OpenCL FP16 | OpenCL native | OpenCL fast |
FSIN            | sin         | half\_sin   | native\_sin   | NONE        |
FCOS            | cos         | half\_cos   | native\_cos   | NONE        |
FTAN            | tan         | half\_tan   | native\_tan   | NONE        |
FASIN           | asin        | NONE        | NONE          | NONE        |
FACOS           | acos        | NONE        | NONE          | NONE        |
NONE (3)        | atan        | NONE        | NONE          | NONE        |
FSINPI          | sinpi       | NONE        | NONE          | NONE        |
FCOSPI          | cospi       | NONE        | NONE          | NONE        |
FTANPI          | tanpi       | NONE        | NONE          | NONE        |
FASINPI         | asinpi      | NONE        | NONE          | NONE        |
FACOSPI         | acospi      | NONE        | NONE          | NONE        |
NONE (2)        | atanpi      | NONE        | NONE          | NONE        |
FSINH           | sinh        | NONE        | NONE          | NONE        |
FCOSH           | cosh        | NONE        | NONE          | NONE        |
FTANH           | tanh        | NONE        | NONE          | NONE        |
FASINH          | asinh       | NONE        | NONE          | NONE        |
FACOSH          | acosh       | NONE        | NONE          | NONE        |
FATANH          | atanh       | NONE        | NONE          | NONE        |
FRSQRT          | rsqrt       | half\_rsqrt | native\_rsqrt | NONE        |
FCBRT           | cbrt        | NONE        | NONE          | NONE        |
FEXP2           | exp2        | half\_exp2  | native\_exp2  | NONE        |
FLOG2           | log2        | half\_log2  | native\_log2  | NONE        |
FEXPM1 (1)      | expm1       | NONE        | NONE          | NONE        |
FLOG1P (1)      | log1p       | NONE        | NONE          | NONE        |
FEXP (1)        | exp         | half\_exp   | native\_exp   | NONE        |
FLOG (1)        | log         | half\_log   | native\_log   | NONE        |
FEXP10          | exp10       | half\_exp10 | native\_exp10 | NONE        |
FLOG10          | log10       | half\_log10 | native\_log10 | NONE        |
FATAN2          | atan2       | NONE        | NONE          | NONE        |
FATAN2PI        | atan2pi     | NONE        | NONE          | NONE        |
FPOW            | pow         | NONE        | NONE          | NONE        |
FROOT           | rootn       | NONE        | NONE          | NONE        |
FHYPOT          | hypot       | NONE        | NONE          | NONE        |
"""]]

Note (1): See "synthesis", below.  FEXPM1, FEXP and FLOG1P, FLOG, may
be synthesised in terms of the other.  FEXPM1 and FLOG1P are more accurate.
It is likely therefore that FLOG and FEXP will be removed.

Note (2) FATANPI is a synthesised alias, below.

Note (3) FATAN2 is a sythesised alias, below.

# List of 2-arg opcodes

[[!table  data="""
opcode    | Description            | pseudo-code                | Extension   |
FATAN2    | atan2 arc tangent      | rd = atan2(rs2, rs1)       | Zarctrignpi |
FATAN2PI  | atan2 arc tangent / pi | rd = atan2(rs2, rs1) / pi  | Zarctrigpi  |
FPOW      | x power of y           | rd = pow(rs1, rs2)         | ZftransAdv  |
FROOT     | x power 1/y            | rd = pow(rs1, 1/rs2)       | ZftransAdv  |
FHYPOT    | hypotenuse             | rd = sqrt(rs1^2 + rs2^2)   | Zftrans     |
"""]]

# List of 1-arg transcendental opcodes

[[!table  data="""
opcode   | Description              | pseudo-code             | Extension  |
FRSQRT   | Reciprocal Square-root   | rd = sqrt(rs1)          | Zfrsqrt    |
FCBRT    | Cube Root                | rd = pow(rs1, 3)        | Zftrans    |
FEXP2    | power-of-2               | rd = pow(2, rs1)        | Zftrans    |
FLOG2    | log2                     | rd = log2(rs1)          | Zftrans    |
FEXPM1   | exponential minus 1      | rd = pow(e, rs1) - 1.0  | Zftrans    |
FLOG1P   | log plus 1               | rd = log(e, 1 + rs1)    | Zftrans    |
FEXP     | exponential              | rd = pow(e, rs1)        | ZftransExt |
FLOG     | natural log (base e)     | rd = log(e, rs1)        | ZftransExt |
FEXP10   | power-of-10              | rd = pow(10, rs1)       | ZftransExt |
FLOG10   | log base 10              | rd = log10(rs1)         | ZftransExt |
"""]]

# List of 1-arg trigonometric opcodes

[[!table  data="""
opcode   | Description              | pseudo-code             | Extension |
FSIN     | sin (radians)            | rd = sin(rs1)           | Ztrignpi    |
FCOS     | cos (radians)            | rd = cos(rs1)           | Ztrignpi    |
FTAN     | tan (radians)            | rd = tan(rs1)           | Ztrignpi    |
FASIN    | arcsin (radians)         | rd = asin(rs1)          | Zarctrignpi |
FACOS    | arccos (radians)         | rd = acos(rs1)          | Zarctrignpi |
FSINPI   | sin times pi             | rd = sin(pi * rs1)      | Ztrigpi |
FCOSPI   | cos times pi             | rd = cos(pi * rs1)      | Ztrigpi |
FTANPI   | tan times pi             | rd = tan(pi * rs1)      | Ztrigpi |
FASINPI  | arcsin / pi              | rd = asin(rs1) / pi     | Zarctrigpi |
FACOSPI  | arccos / pi              | rd = acos(rs1) / pi     | Zarctrigpi |
FATANPI  | arctan / pi              | rd = atan(rs1) / pi     | Zarctrigpi |
FSINH    | hyperbolic sin (radians) | rd = sinh(rs1)          | Zfhyp |
FCOSH    | hyperbolic cos (radians) | rd = cosh(rs1)          | Zfhyp |
FTANH    | hyperbolic tan (radians) | rd = tanh(rs1)          | Zfhyp |
FASINH   | inverse hyperbolic sin   | rd = asinh(rs1)         | Zfhyp |
FACOSH   | inverse hyperbolic cos   | rd = acosh(rs1)         | Zfhyp |
FATANH   | inverse hyperbolic tan   | rd = atanh(rs1)         | Zfhyp |
"""]]

# Synthesis, Pseudo-code ops and macro-ops

The pseudo-ops are best left up to the compiler rather than being actual
pseudo-ops, by allocating one scalar FP register for use as a constant
(loop invariant) set to "1.0" at the beginning of a function or other
suitable code block.

* FRCP rd, rs1 - pseudo-code alias for rd = 1.0 / rs1
* FATAN - pseudo-code alias for rd = atan2(rs1, 1.0) - FATAN2
* FATANPI - pseudo alias for rd = atan2pi(rs1, 1.0) - FATAN2PI
* FSINCOS - fused macro-op between FSIN and FCOS (issued in that order).
* FSINCOSPI - fused macro-op between FSINPI and FCOSPI (issued in that order).

FATANPI example pseudo-code:

    lui t0, 0x3F800 // upper bits of f32 1.0
    fmv.x.s ft0, t0
    fatan2pi.s rd, rs1, ft0

Hyperbolic function example (obviates need for Zfhyp except for high-performance or correctly-rounding):

    ASINH( x ) = ln( x + SQRT(x**2+1))

LOG / LOGP1 example:

    LOG(x) = LOGP1(x - 1.0)
    EXP(x) = EXPM1(x) + 1.0

# To evaluate: should LOG be replaced with LOG1P (and EXP with EXPM1)?

RISC principle says "exclude LOG because it's covered by LOGP1 plus an ADD".
Research needed to ensure that implementors are not compromised by such
a decision
<http://lists.libre-riscv.org/pipermail/libre-riscv-dev/2019-August/002358.html>

correctly-rounded LOG will return different results than LOGP1 and ADD.
Likewise for EXP and EXPM1

