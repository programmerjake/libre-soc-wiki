# HDL workflow

This section describes the workflow and some best practices for developing the LibreSoC hardware. We use nmigen, yosys and symbiyosys, and this page is intended not just to help you get set up, it is intended to help advise you of some tricks and practices that will help you become effective team contributors.

It is particularly important to bear in mind that we are not just "developing code", here: we are creating a "lasting legacy educational resource" for other people to learn from, and for businesses and students alike to be able to use, learn from and augment for their own purposes.

It is also important to appreciate and respect that we are funded under NLNet's Privacy and Enhanced Trust Programme <http://nlnet.nl/PET>. Full transparency, readability, documentation, effective team communication and formal mathematical proofs for all code at all levels is therefore paramount.

# Hardware

RAM is the biggest requirement. Minimum 16GB, the more the better (32 or 64GB starts to reach "acceptable" levels.  Disk space is not hugely critical: 256GB SSD should be more than adequate.  Simulations and FPGA compilations however are where raw processing power is a must.  High end Graphics Cards are nonessential.

What is particularly useful is to have not only hi-res screens (curved is *strongly* recommended if the LCD is over 24in wide, to avoid eyeballs going "prism" through longterm use), and to have several of them: the more the better.  Either a DisplayLink UD160A (or more modern variant) or simply using a second (lower spec hardware) machine is really effective.

Also it is really recommended to have a UHD monitor (4k - 3840x2160), or at least 2560x1200.  If given a choice, 4:3 aspect ratio is better than 16:9 particularly when using several of them. However, caveat (details below): please when editing do not assume that everyone will have access to such high resolution screens.

# Operating System

First install and become familiar with Debian (ubuntu if you absolutely must) for standardisation cross-team and so that toolchain installation is greatly simplified.  yosys in particular warns that trying to use Windows, *BSD or MacOS will get you into a world of pain.

Only a basic GUI desktop is necessary: fvwm2, xfce4, lxde are perfectly sufficient (alongside wicd-gtk for network management). Other more complex desktops can be used however may consume greater resources.

# editors and editing

Whilst this is often a personal choice, the fact that many editors are GUI based and run fullscreen with the entire right hand side *and* middle *and* the majority of the left side of the hi-res screen entirely unused and bereft of text leaves experienced developers both amused and puzzled.

At the point where such fullscreen users commit code with line lengths well over 160 characters, that amusement quickly evaporates.

Where the problems occur with fullscreen editor usage is when a project is split into dozens if not hundreds of small files (as this one is). At that point it becomes pretty much essential to have as many as six to eight files open *and on-screen* at once, without overlaps i.e. not in hidden tabs, next to at least two if not three additional free and clear terminals into which commands are regularly and routinely  typed (make, git commit, nosetests3 etc).

(hint/tip: fvwm2 set up with "mouse-over to raise focus, rather than additionally requiring a mouseclick, can save a huge amount of cumulative development time here, switching between editor terminal(s) and the command terminals).

Once this becomes necessary, it it turn implies that having greater than 80 chars per line - and running editors fullscreen -is a severe hindance to an essential *and highly effective* workflow technique.

Additionally, care should be taken to respect that not everyone will have 200+ column editor windows. They may only have a 1280 x 800 laptop which barely fits 2 80x53 xterms side by side.  Consequently, having excessively long functions is also a hindrance to others, as such developers with limited screen resources would need to continuously page-up and page-down to read the code even of a single function, in full.

This helps explain in part, below, why compliance with pep8 is enforced, including its 80 character limit.  In short: not everyone has the same "modern" GUI workflow or has access to the same computing resources as you, so please do respect that.

# Software prerequisites

Whilst many resources online advocate "sudo" in front of all root-level commands below, this quickly becomes tiresome. run "sudo bash", get a root prompt, and save yourself some typing.

* sudo bash
* apt-get install vim exuberant-ctags
* apt-get install build-essential
* apt-get install git python3.7 python3.7-dev python-nosetest3
* apt-get install graphviz xdot gtkwave
* return to user prompt (ctrl-d)

## yosys

Follow the source code (git clone) instructions here: <http://www.clifford.at/yosys/download.html>

Do not try to use a fixed revision (currently 0.9), nmigen is evolving and frequently interacts with yosys

## symbiyosys

Follow the instructions here: <https://symbiyosys.readthedocs.io/en/latest/quickstart.html#installing>

You do not have to install all of those (avy, boolector can be left out if desired) however the more that are installed the more effective the formal proof scripts will be (less resource utilisation in certain circumstances).

## nmigen

nmigen may be installed as follows:

* mkdir ~/src
* cd !$
* git clone https://github.com/m-labs/nmigen.git
* cd nmigen
* sudo bash
* python3 setup.py develop
* ctrl-d

testing can then be carried out with "python3 setp.py test"

# Registering for git repository access

After going through the onboarding process and having agreed to take responsibility for certain tasks, ask on the mailing list for git repository access, sending in a public key (id_rsa.pub). If you do not have one generate it with ssh-keygen -t rsa.

NEVER SEND ANYONE THE PRIVATE KEY.  By contrast the public key, on account of being public, is perfectly fine to make... err... public.

Create a file ~/.ssh/config with the following lines:

    Host git.libre-riscv.org
    Port 922

Wait for the Project Admin to confirm that the ssh key has been added to the required repositories.  Once confirmed,
you can clone any of the repos at http://git.libre-riscv.org:

    git clone gitolite3@git.libre-riscv.org:REPONAME.git

# Development Rules

team communication:

* communicate on the mailing list or the bugtracker an intent to take responsibility for a particular task.
* assign yourself as the bug's owner
* *keep in touch* about what you are doing, and why.
* if you cannot do sonething that you gave taken responsibility for, then unless it is a dire emergency please say so, on-list. we won't mind. we'll help sort it out.

for actual code development:

* **do not commit autogenerated output**. write a shell script and commit that, or add a Makefile to run the command that generates the output, but **do not** add the actual output of **any** command to the repository.  ever.  this is really important.  even if it is a human-readable file rather than a binary object file.
* if the command needed to create any given autogenerated output is not currently in the list of dependencies, first consult on the list if it is okay to make that command become a hard dependency of the project (hint: java, node.js php and .NET commands will cause delays in responses due to list participants laughing hysterically too much), and after a decision is made, document the dependency and how its source code is obtained and built.
* if you find yourself repeating commands regularly, chances are high that someone else will need to run them, too. therefore, put them into a .sh shell script (and/or a Makefile) and document them at the very minimum in README or INSTALL.txt or somewhere in a docs folder as appopriate.  if unsure, ask on the mailing list for advice.
* plan in advance to write not just code but a full test suite for that code.  **this is not optional**. large python projects that do not have unit tests **FAIL**.
* edit files making minimal *single purpose* modifications (even if it involves multiple files. Good extreme example: globally changing a function name across an entire codebase is one purpose, one commit, yet hundreds of files).
* prior to committing make sure that relevant unit tests pass, or that the change is a zero-impact addition.
* commit no more than 5 to 10 lines at a time, with a CLEAR message (no "added this" or "changed that").
* if as you write you find that the commit message involves a *list* of changes or the word "and", then STOP. do not proceed: it is a "red flag" that the commit has not been properly broken down into separate-purpose commits. ask for advice on-list.
* if it is essential to commit large amounts of code, ensure that it is **not** in use **anywhere** by any other code.

the reason for the above is because python is a weakly typed language.  make one tiny change at the base level of the class hierarchy and the effect may be disastrous.

therefore, if you are absolutely certain that a new addition (new file, new class, new function) is not going to have any side-effects, committing it (a large amount of code) is perfectly fine.

as a general rule, however, do not use this an an excuse to write code first then write unit tests as an afterthought.  write *less* code *in conjunction* with its (more basic) unit tests, instead.

the reason for separating out commits to single purpose only becomes obvious (and regretted if not followed) when, months later, a mistake has to be tracked down and reverted.  if the commit does not have an easy-to-find message, it cannot even be located, and once found, if the commit confuses several unrelated changes, not only the diff is larger than it should be, the reversion process becomes extremely painful.

* all code needs to conform to pep8.  use either pep8checker or better run autopep8.  however whenever committing whitespace changes, *make a separate commit* with a commit message "whitespace" or "autopep8 cleanup".
* pep8 REQUIRES no more than 80 chars per line. this is non-negotiable. if you think you need greater than 80 chars, it *fundamentally* indicates poor code design. split the code down further into smaller classes and functions.
* TBD there is a docstring checker.  at the minimum make sure to have an SPD license header, module header docstring, class docstring and function docstrings on at least non-obvious functions.
* make liberal but not excessive use of comments.  describe a group of lines of code, with terse but useful comments describing the purpose, documenting any side-effects, and anything that could trip you or other developers up.  unusual coding techniques should *definitely* contain a warning.
* unless they are very closely related, only have one module (one class) per file. a file only 25 lines long including imports and docstrings is perfectly fine however don't force yourself. again, if unsure, ask on-list.
* *keep files short and simple*. see below as to why
* create a decent directory hierarchy but do not go mad. ask for advice if unsure
* please do not use "from module import *". it is extremely bad practice, causes unnecessary resource utilisation, makes code readability extremely difficult, and results in unintended side-effects.
* try to keep both filenames and variable names short but not ridiculously obtuse. an interesting compromise on imports is "from ridiculousfilename import longsillyname as lsn", and to assign variables as well: "comb = m.d.comb" followed by multiple "comb += nmigen_stmt" lines is a good trick that can reduce code indentation by 6 characters without reducing clarity.

regarding code structure: we decided to go with small modules that are both easy to analyse, as well as fit onto a single page and be readable when displayed as a visual graph on a full UHD monitor.  this is done as follows:

* using the capability of nmigen (TODO crossref to example) output the module to a yosys ilang (.il) file
* in a separate terminal window, run yosys
* at the yosys prompt type "read_ilang modulename.il"
* type "show top" and a graphviz window should appear. note that typing show, then space, then pressing the tab key twice will give a full list of submodules (one of which will be "top")

you can now fullsize the graphviz window and scroll around.  if it looks reasonably obvious at 100% zoom, i.e the connections can be clearly related in your mind back to the actual code (by matching the graph names against signals and modules in the original nmigen code) and the words are not tiny when zoomed out, and connections are not total incomprehensible spaghetti, then congratulations, you have well-designed code. If not, then this indicates a need to split the code further into submodules and do a bit more work.

The reasons for doing a proper modularisation job are several-fold:

* firstly, we will not be doing a full automated layout-and-hope using alliance/coriolis2, we will be doing leaf-node thru tree node half-automated half-manual layout, finally getting to the floorplan, then revising and iteratively adjusting.
* secondly, examining modules at the gate level (or close to it) is just good practice.  poor design creeps in by *not* knowing what the tools are actually doing (word to experienced developers: yes, we know that the yosys graph != final netlist).
* thirdly, unit testing, particularly formal proofs, is far easier on small sections of code, and complete in a reasonable time.

# TODO Tutorials

Find appropriate tutorials for nmigen and yosys, as well as symbiyosys.

* Although a verilog example this is very useful to do <https://symbiyosys.readthedocs.io/en/latest/quickstart.html#first-step-a-simple-bmc-example>
* There exist several nmigen examples which are also executable <https://github.com/m-labs/nmigen/tree/master/examples/>
* This tutorial looks pretty good and will get you started <http://blog.lambdaconcept.com/doku.php?id=nmigen:nmigen_install> and walks not just through simulation, it takes you through using gtkwave as well.

