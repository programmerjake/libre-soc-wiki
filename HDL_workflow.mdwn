# HDL workflow

This section describes the workflow for developing the LibreSoC.

# Hardware

RAM is the biggest requirement. Minimum 16GB, the more the better (32 or 64GB starts to reach "acceptable" levels.  Disk space is not hugely critical: 256GB SSD should be more than adequate.  Simulations however are where raw processing power is a must.  High end Graphics Cards are nonessential.

# Operating System

First install Debian (ubuntu if you absolutely must) for standardisation cross-team and so that toochain installation is greatly simplified.

A basic GUI desktop is necessary: fvwm2, xfce, lxde are perfectly sufficient (alongside wicd-gtk for network management). Other more complex desktops can be used however may consume greater resources.

# Software prerequisites

Whilst many resources online advocate sudo in front of all of the root-level commands below, this is extremely irritating. run "sudo bash", get a root prompt, and save some typing.

* apt-get install build-essential
* apt-get install git python3.7 python3.7-dev python-nosetest3
* apt-get install graphviz xdot
* return to user prompt (ctrl-d)

## yosys

Follow the source code (git clone) instructions here: <http://www.clifford.at/yosys/download.html>

Do not try to use a fixed revision, nmigen is evolving and frequently interacts with yosys

## symbiyosys

Follow the instructions here: <https://symbiyosys.readthedocs.io/en/latest/quickstart.html#installing>

You do not have to install all of those (avy, boolector can be left out if desired).

## nmigen

nmigen may be installed as follows:

* mkdir ~/src
* cd !$
* git clone https://github.com/m-labs/nmigen.git
* cd nmigen
* sudo bash
* python3 setup.py develop
* ctrl-d

testing can then be carried out with "python3 setp.py test"

# Registering for git repository access

After going through the onboarding process and having agreed to take responsibility for certain tasks, ask on the mailing list for git repository access, sending in a public key (id_rsa.pub). If you do not have one generate it with ssh-keygen -t rsa.

NEVER SEND ANYONE THE PRIVATE KEY.  By contrast the public key, on account of being public, is perfectly fine to make... err... public.

Create a file ~/.ssh/config with the following lines:

    Host git.libre-riscv.org
    Port 922

Wait for the Project Admin to confirm that the ssh key has been added to the required repositories.  Once confirmed,
you can clone any of the repos at http://git.libre-riscv.org:

    git clone gitolite3@git.libre-riscv.org:REPONAME.git

# Development Rules

team communication:

* communicate on the mailing list or the bugtracker an intent to take responsibility for a particular task.
* assign yourself as the bug's owner
* *keep in touch* about what you are doing, and why.
* if you cannot do sonething that you gave taken responsibility for, then unless it is a dire emergency please say so, on-list. we won't mind. we'll help sort it out.

for actual code development:

* **do not commit autogenerated output**. write a shell script and commit that, or add a Makefile to run the command that generates the output, but **do not** add the actual output of **any** command to the repository.  ever.  this is really important.  even if it is a human-readable file rather than a binary object file.
* if the command needed to create any given autogenerated output is not currently in the list of dependencies, first consult on the list if it is okay to make that command become a hard dependency of the project (hint: java, node.js php and .NET commands will cause delays in responses due to list participants laughing hysterically too much), and after a decision is made, document the dependency and how its source code is obtained and built.
* plan in advance to write not just code but a full test suite for that code.  **this is not optional**. large python projects that do not have unit tests **FAIL**.
* edit files making minimal *single purpose* modifications.
* prior to committing make sure that relevant unit tests pass, or that the change is a zero-impact addition.
* commit no more than 5 to 10 lines at a time, with a CLEAR message (no "added this" or "changed that"). if the commit involves a list of changes or the word "and" it is a "red flag" that the commit has not been properly broken down.
* if it is essential to commit large amounts of code, ensure that it is **not** in use **anywhere** by any other code.

the reason for the above is because python is a weakly typed language.  make one tiny change at the base level of the class hierarchy and the effect may be disastrous.

* all code needs to conform to pep8.  use either pep8checker or better run autopep8.  however whenever committing whitespace changes, *make a separate commit* with a commit message "whitespace" or "autopep8 cleanup".
* pep8 REQUIRES no more than 80 chars per line. this is non-negotiable. if you think you need greater than 80 chars, it *fundamentally* indicates poor code design. split the code down further into smaller classes and functions.
* TBD there is a docstring checker.  at the minimum make sure to have an SPD license heafer, module header docstring, class docstring and function docstrings on non-obvious functions
* make liberal but not excessive use of comments.
* unless they are very closely related, only have one module (one class) per file. a file only 25 lines long including imports and docstrings is perfectly fine.
* *keep files short and simple*. see below as to why
* create a decent directory hierarchy but do not go mad. ask for advice if unsure
* please do not use "from module import *". it is extremely bad practice.

regarding code structure: we decided to go with small modules that are both easy to analyse, as well as fit onto a single page and be readable when displayed as a visual graph on a full UHD monitor.  this is done as follows:

* using the capability of nmigen (TODO crossref to example) output the module to a yosys ilang (.il) file
* in a separte terminal window run yosys
* at the yosys prompt type "read_ilang modulename.il"
* type "show top" and a graphviz window should appear. note that typing show, then space, then pressing the tab key twice will give a full list of submodules (one of which will be "top")

you can now fullsize the graphviz window and scroll around.  if it looks reasonably obvious, i.e the connections can be clearly related in your mind back to the actual code (by matching the graph names against signals and modules in the original nmigen code) and the words are not tiny when zoomed out, and connections are not total incomprehensible spaghetti, then congratulations, you have well-designed code. If not, then this indicates a need to split the code further into submodules.

The reasons for doing a proper modularisatoion job are several-fold:

* firstly, we will not be doing a full automated layout-and-hope using alliance/ciriolis2, we will be doing leaf-node thru tree node half-automated half-manual layout, finally getting to the floorplan, then revising and iteratively adjusting.
* secondly, examining modules at the gate level (or close to it) is just good practice.  poor design creeps in by *not* knowing what the tools are actually doing.
* thirdly, unit testing, particularly formal proofs, is far easier on small sections of code.

