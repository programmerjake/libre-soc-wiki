# 16 bit Compressed

See:

* <https://bugs.libre-soc.org/show_bug.cgi?id=238>
* <https://ftp.libre-soc.org/VLE_314-68105.pdf> VLE Encoding

This one is a conundrum.  OpenPOWER ISA was never designed with 16
bit in mind.  VLE was added 10 years ago but only by way of marking
an entire 64k page as "VLE".  With VLE not maintained it is not
fully compatible with current PowerISA.

Here, in order to embed 16 bit into a predominantly 32 bit stream the
overhead of using an entire 16 bits just to switch into Compressed mode
is itself a significant overhead.  The situation is made worse by 5 bits
being taken up by Major Opcode space, leaving only 11 bits to allocate
to actual instructions.

In addition we would like to add SV-C32 which is a Vectorised version
of 16 bit Compressed, and ideally have a variant that adds the 27-bit
prefix format from SV-P64, as well.

Potential ways to reduce pressure on the 16 bit space are:

* To provide "paging".  This involves bank-switching to alternative optimised encodings for specific workloads
* To enter "16 bit mode" for durations specified at the start
* To reserve one bit of every 16 bit instruction to indicate that the 16 bit mode is to continue to be sustained

This latter would be useful in the Vector context to have an alternative
meaning: as the bit which determines whether the instruction is 11-bit
prefixed or 27-bit prefixed:

    0 1 2 3 4 5 6 7 8 9 a b c d e f |
    |major op | 11 bit vector prefix|
    |16 bit opcode  alt vec. mode ^ |
    | extra vector prefix if alt set|

Using a major opcode to enter 16 bit mode, leaves 11 bits to find
something to use them for:

    0 1 2 3 4 5 6 7 8 9 a b c d e f |
    |major op | what to do here   1 |
    |16 bit    stay in 16bit mode 1 |
    |16 bit    stay in 16bit mode 1 |
    |16 bit       exit 16bit mode 0 |

One possibility is that the 11 bits are used for bank selection, with
some room for additional context such as altering the registers used
for the 16 bit operations (bank selection of which scalar regs)

Another is to use the 11 bits for only the utmost commonly used
instructions.  That being the case then even one of those 11 bits would
also need to be dedicated to saying if 16 bit mode is to be continued.
10 bits remain for actual opcodes!

# Opcode Allocation Ideas

* one bit from the 16-bit mode is used to indicate that 32-bit mode
  is to be dropped into for only one single instruction
  <https://bugs.libre-soc.org/show_bug.cgi?id=238#c2>

## Opcodes exploration (Attempt 1)

Switching between different encoding modes is controlled by M (alone)
in 10-bit mode, and M and N in 16-bit mode.

* M in 10-bit mode if zero indicates that following instructions are
  standard OpenPOWER ISA 32-bit encoded (including, redundantly,
  further 10/16-bit instructions)
* M in 10-bit mode if 1 indicates that following instructions are
  in 16-bit encoding mode

Once in 16-bit mode:

* 0b01 (M=1, N=0): stay in 16-bit mode
* 0b00: leave 16-bit mode permanently (return to standard OpenPOWER ISA)
* 0b10: leave 16-bit mode for one cycle (return to standard OpenPOWER ISA)
* 0b11: free to be used for something completely different.

The current "top" idea for 0b11 is to use it for a new encoding format
of predominantly "immediates-based" 16-bit instructions (branch-conditional,
addi, mulli etc.)

* The Compressed Major Opcode is in bits 5-7.
* Minor opcode in bit 8.
* In some cases bit 9 is taken as an additional sub-opcode, followed
  by bits 0-4 (for CR operations)
* M+N mode-switching is not available for C-Major 0b001 or 0b111
* 10 bit mode may be expanded by 16 bit mode, adding capabilities
  that do not fit in the extreme limited space.

### Immediate Opcodes

only available in 16-bit mode, and only available when M=1 and N=1

    | 0 | 1  | 2 3 4 | | 567.8  | 9ab  | c d e | f |
    | 1 | i2 |  RT   | | 010.i3 | RB|0 | imm   | 1 | addi.
    | 1 | i2         | | 011.0  | RB   | imm   | 1 | cmpdi
    | 1 | i2         | | 011.1  | RB   | imm   | 1 | cmpwi
    | 1 | i2         | | 100.0  | RT   | imm   | 1 | sti
    | 1 | i2         | | 100.1  | RT   | imm   | 1 | fstwi
    | 1 | i2         | | 101.0  | RA   | imm   | 1 | ldi
    | 1 | i2         | | 101.1  | RA   | imm   | 1 | lwi
    | 1 | i2         | | 110.0  | RA   | imm   | 1 | flwi
    | 1 | i2         | | 110.1  | RA   | imm   | 1 | fldi

Construction of immediate:

* addi is EXTS(i3||i2||imm) to give a 5-bit range -32 to +31
* all others are EXTS(i2||imm) to give a 7-bit range -128 to +127
  (further for LD/ST due to word/dword-alignment)

Further Notes:

* bc also has an immediate mode, listed below in Branch section
* for LD/ST, offset is aligned.  8-byte: i2||imm||0b000 4-byte: 0b00
* SV Prefix over-rides help provide alternative bitwidths for LD/ST
* RB|0 if RB is zero, addi. becomes "li"
 - this only works if RT takes part of opcode
 - mv is also possible by specifying an immediate of zero


### Branch

Note that illeg and nop are all zeros, including in the 16-bit mode.
Given that C is allocated to OpenPOWER ISA Major opcodes EXT000 and
EXT001 this ensures that in both 10-bit *and* 16-bit mode, a 16-bit
run of all zeros is considered "illegal" whilst 0b0000.0000.1000.0000
is "nop"

    | 16-bit mode | | 10-bit mode                 |
    | 0 | 1 | 234 | | 567.8  | 9  ab | c   de | f |
    | 0 | 0   000 | | 000.0  | 0  00 | 0   00 | 0 | illeg
    | 0 | 0   000 | | 000.1  | 0  00 | 0   00 | 0 | nop
    | N | offs2   | | 000.LK | offs!=0        | M | b, bl
    | 1 | offs2   | | 000.LK | BI    | BO1 oo | 1 | bc, bcl
    | N | BO3 BI3 | | 001.0  | LK BI | BO     | M | bclr, bclrl

16 bit mode:

* bc only available when N,M=0b11
* offs2 extends offset in MSBs
* BI3 extends BI in MSBs to allow selection of full CR
* BO3 extends BO
* bc offset constructed from oo as LSBs and offs2 as MSBs
* bc BI allows selection of all bits from CR0 or CR1
* bc CR check is always active (as if BO0=1) therefore BO1 inverts

10 bit mode:

* illegal (all zeros) covers part of branch (offs=0,M=0,LK=0)
* nop also covers part of branch (offs=0,M=0,LK=1)
* bc **not available** in 10-bit mode
* BO[0] enables CR check, BO[1] inverts check
* BI refers to CR0 only (4 bits of)
* no Branch Conditional with immediate
* no Absolute Address
* CTR mode allowed with BO[2] for b only.
* offs is to 2 byte (signed) aligned
* all branches to 2 byte aligned

### LD/ST

    | 16-bit mode       | | 10-bit mode               |
    | 0   | 1   | 2 3 4 | | 567.8 | 9 a b | c d e | f |
    | RB2 | RA2 |  RT   | | 001.1 | 1  RA | 0  RB | M | fld
    | RA2 | RT2 |  RB   | | 001.1 | 1  RA | 1  RT | M | fst
    |     |     |  RT   | | 111.0 |  RA   |  RB   | M | ld
    |     |     |  RB   | | 111.1 |  RA   |  RT   | M | st

* elwidth overrides can set different widths

16 bit mode:

* F=1 is FLD, FST
* RA2 extends RA to 3 bits (MSB)
* RT2 extends RT to 3 bits (MSB)

10 bit mode:

* RA and RB are only 2 bit (0-3)
* for LD, RT is implicitly RB: "ld RT=RB, RA(RB)"
* for ST, there is no offset: "st RT, RA(0)"

### Arithmetic

    | 16-bit mode   | | 10-bit mode             |
    | 0 | 1 | 2 3 4 | | 567.8 | 9ab | c d e | f |
    | N |   |  RT   | | 010.0 | RB  | RA!=0 | M | add
    | N |   |  RT   | | 010.1 | RB  | RA    | M | mul
    | N |   | RT!=0 | | 011.0 | RB  | RA!=0 | M | sub.
    | N | 0 | 000   | | 011.0 | RB  | RA!=0 | M | cmpw
    | N | 1 | 000   | | 011.0 | RB  | RA!=0 | M | cmpl
    | N |   |  RT   | | 011.0 | RB  | 000   | M | neg.

10 bit mode:

* sub. default CR target is CR0
* for (RA|0) when RA=0 the input is a zero immediate,
  meaning that sub. becomes neg.
* RT is implicitly RB: "add RT(=RB), RA, RB"
* Opcode 0b010.0 RA=0 is not missing from the above:
  it is a system-wide instruction, "cbank" (section below)

### Logical

    | 16-bit mode   | | 10-bit mode             |
    | 0 | 1 | 2 3 4 | | 567.8 | 9ab | c d e | f |
    | N | 0 |  RT   | | 100.0 | RB  | RA!=0 | M | and
    | N | 0 |  RT   | | 100.1 | RB  | RA!=0 | M | nand
    | N | 0 |  RT   | | 101.0 | RB  | RA!=0 | M | or
    | N | 0 |  RT   | | 101.1 | RB  | RA!=0 | M | nor
    | N | 0 |  RT   | | 100.0 | RB  | 0 0 0 | M | extsw
    | N | 0 |  RT   | | 100.1 | RB  | 0 0 0 | M | cntlz
    | N | 0 |  RT   | | 101.0 | RB  | 0 0 0 | M | popcnt
    | N | 0 |  RT   | | 101.1 | RB  | 0 0 0 | M | not

16-bit mode only:

    | 0 | 1 | 2 3 4 | | 567.8 | 9ab | c d e | f |
    | N | 1 |  RT   | | 100.0 | RB  | RA!=0 | M |
    | N | 1 |  RT   | | 100.1 | RB  | RA!=0 | M |
    | N | 1 |  RT   | | 101.0 | RB  | RA!=0 | M | xor
    | N | 1 |  RT   | | 101.1 | RB  | RA!=0 | M | eqv (xnor)
    | N | 1 |  RT   | | 100.0 | RB  | 0 0 0 | M | extsb
    | N | 1 |  RT   | | 100.1 | RB  | 0 0 0 | M | cnttz
    | N | 1 |  RT   | | 101.0 | RB  | 0 0 0 | M |
    | N | 1 |  RT   | | 101.1 | RB  | 0 0 0 | M | extsh

10 bit mode:

* for (RA|0) when RA=0 the input is a zero immediate,
  meaning that nor becomes not
* cntlz, popcnt, exts **not available** in 10-bit mode
* RT is implicitly RB: "and RT(=RB), RA, RB"

### Floating Point

Note here that elwidth overrides (SV Prefix) can be used to select FP16/32/64

    | 16-bit mode   | | 10-bit mode             |
    | 0 | 1 | 2 3 4 | | 567.8 | 9ab | c d e | f |
    | N |   |  RT   | | 011.1 | RB  | RA!=0 | M | fsub.
    | N | 0 |  RT   | | 110.0 | RB  | RA!=0 | M | fadd
    | N | 0 |  RT   | | 110.1 | RB  | RA!=0 | M | fmul
    | N | 0 |  RT   | | 011.1 | RB  | 0 0 0 | M | fneg.
    | N | 0 |  RT   | | 110.0 | RB  | 0 0 0 | M |
    | N | 0 |  RT   | | 110.1 | RB  | 0 0 0 | M |

16-bit mode only:

    | 0 | 1 | 2 3 4 | | 567.8 | 9ab | c d e | f |
    | N | 1 |  RT   | | 011.1 | RB  | RA!=0 | M |
    | N | 1 |  RT   | | 110.0 | RB  | RA!=0 | M |
    | N | 1 |  RT   | | 110.1 | RB  | RA!=0 | M | fdiv
    | N | 1 |  RT   | | 011.1 | RB  | 0 0 0 | M | fabs.
    | N | 1 |  RT   | | 110.0 | RB  | 0 0 0 | M | fmr.
    | N | 1 |  RT   | | 110.1 | RB  | 0 0 0 | M |

10 bit mode:

* fsub. fneg. and fmr. default target is CR1
* fmr. is **not available** in 10-bit mode
* fdiv is **not available** in 10-bit mode

16 bit mode:

* fmr. copies RB to RT (and sets CR1)

### Condition Register

    | 16-bit mode   | | 10-bit mode            |
    | 0 1 2 3 | 4   | | 567.8 | 9 ab | cde | f |
    | 0 0 0 0 | BF2 | | 001.1 | 0 BF | BFA | M | mcrf
    | 0 0 0 1 | BA2 | | 001.1 | 0 BA | BB  | M | crnor
    | 0 1 0 0 | BA2 | | 001.1 | 0 BA | BB  | M | crandc
    | 0 1 1 0 | BA2 | | 001.1 | 0 BA | BB  | M | crxor
    | 0 1 1 1 | BA2 | | 001.1 | 0 BA | BB  | M | crnand
    | 1 0 0 0 | BA2 | | 001.1 | 0 BA | BB  | M | crand
    | 1 0 0 1 | BA2 | | 001.1 | 0 BA | BB  | M | creqv
    | 1 1 0 1 | BA2 | | 001.1 | 0 BA | BB  | M | crorc
    | 1 1 1 0 | BA2 | | 001.1 | 0 BA | BB  | M | cror

10 bit mode:

* mcrf BF is only 2 bits which means the destination is only CR0-CR3
* CR operations: **not available** in 10-bit mode (but mcrf is)

16 bit mode:

* mcrf BF2 extends BF (in MSB) to 3 bits
* CR operations: destination register is same as BA.
* CR operations: only possible on CR0 and CR1

SV (Vector Mode):

* CR operations: greatly extended reach/range (useful for predicates)

### System

cbank: Selection of Compressed-encoding "Bank".  Different "banks" give different
meanings to opcodes.
Example: CBank=0b001 is heavily optimised to A/Video
Encode/Decode.

    | 16-bit mode | | 10-bit mode               |
    | 0 | 1 2 3 4 | | 567.8 | 9 a b | c d e | f |
    | N |   Bank2 | | 010.0 | CBank | 0 0 0 | M | cbank

**not available** in 10-bit mode:

    | 0 1 2 3 | 4  | | 567.8 | 9 ab | c d e  | f |
    | 1 1 1 1 | 0  | | 001.1 | 0 00 |  RT    | M | mtlr
    | 1 1 1 1 | 0  | | 001.1 | 0 01 |  RT    | M | mtctr
    | 1 1 1 1 | 0  | | 001.1 | 0 11 |  RT    | M | mtcr
    | 1 1 1 1 | 1  | | 001.1 | 0 00 |  RA    | M | mflr
    | 1 1 1 1 | 1  | | 001.1 | 0 01 |  RA    | M | mfctr
    | 1 1 1 1 | 1  | | 001.1 | 0 11 |  RA    | M | mfcr

### Unallocated

    | 0 1 2 3 | 4  | | 567.8 | 9 ab | c d e  | f |
    | 0 0 1 0 |    | | 001.1 | 0    |        | M |
    | 0 0 1 1 |    | | 001.1 | 0    |        | M |
    | 0 1 0 1 |    | | 001.1 | 0    |        | M |
    | 1 0 1 0 |    | | 001.1 | 0    |        | M |
    | 1 0 1 1 |    | | 001.1 | 0    |        | M |
    | 1 1 0 0 |    | | 001.1 | 0    |        | M |
    | 1 1 1 1 | 0  | | 001.1 | 0 10 |        | M |
    | 1 1 1 1 | 1  | | 001.1 | 0 10 |        | M |

