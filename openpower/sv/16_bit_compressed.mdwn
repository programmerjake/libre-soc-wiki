# 16 bit Compressed

See:

* <https://bugs.libre-soc.org/show_bug.cgi?id=238>
* <https://ftp.libre-soc.org/VLE_314-68105.pdf> VLE Encoding

This one is a conundrum.  OpenPOWER ISA was never designed with 16
bit in mind.  VLE was added 10 years ago but only by way of marking
an entire 64k page as "VLE".  With VLE not maintained it is not
fully compatible with current PowerISA.

Here, in order to embed 16 bit into a predominantly 32 bit stream the
overhead of using an entire 16 bits just to switch into Compressed mode
is itself a significant overhead.  The situation is made worse by 5 bits
being taken up by Major Opcode space, leaving only 11 bits to allocate
to actual instructions.

In addition we would like to add SV-C32 which is a Vectorised version
of 16 bit Compressed, and ideally have a variant that adds the 27-bit
prefix format from SV-P64, as well.

Potential ways to reduce pressure on the 16 bit space are:

* To provide "paging".  This involves bank-switching to alternative optimised encodings for specific workloads
* To enter "16 bit mode" for durations specified at the start
* To reserve one bit of every 16 bit instruction to indicate that the 16 bit mode is to continue to be sustained

This latter would be useful in the Vector context to have an alternative
meaning: as the bit which determines whether the instruction is 11-bit
prefixed or 27-bit prefixed:

    0 1 2 3 4 5 6 7 8 9 a b c d e f |
    |major op | 11 bit vector prefix|
    |16 bit opcode  alt vec. mode ^ |
    | extra vector prefix if alt set|

Using a major opcode to enter 16 bit mode, leaves 11 bits to find
something to use them for:

    0 1 2 3 4 5 6 7 8 9 a b c d e f |
    |major op | what to do here   1 |
    |16 bit    stay in 16bit mode 1 |
    |16 bit    stay in 16bit mode 1 |
    |16 bit       exit 16bit mode 0 |

One possibility is that the 11 bits are used for bank selection, with
some room for additional context such as altering the registers used
for the 16 bit operations (bank selection of which scalar regs)

Another is to use the 11 bits for only the utmost commonly used
instructions.  That being the case then even one of those 11 bits would
also need to be dedicated to saying if 16 bit mode is to be continued.
10 bits remain for actual opcodes!

# Opcode Allocation Ideas

* one bit from the 16-bit mode is used to indicate that 32-bit mode
  is to be dropped into for only one single instruction
  <https://bugs.libre-soc.org/show_bug.cgi?id=238#c2>

## Opcodes exploration (Attempt 1)

### Branch

10 bit mode may be expanded by 16 bit mode later, adding capabilities
that do not fit in the extreme limited space.

    | 0 1 | 2 3 4 | | 567 | 8 9 a | b c d | e  | f |
    |   offs2     | | 000 |    offs       | LK | 1 | b
    | BO2 | BI3   | | 001 | 0  BI | 0  BO | LK | 1 | bclr
    | BO2 | BI3   | | 001 | 0  BI | 1  BO | LK | 1 | bctar

16 bit mode:

* offs2 extends offset in MSBs
* BI3 extends BI in MSBs to allow selection of full CR
* BO2 extends BO

10 bit mode:

* BO[0] enables CR check, BO[1] inverts check
* BI refers to CR0 only (4 bits of)
* no Branch Conditional with immediate
* no Absolute Address
* no CTR mode (and no bctr)
* offs is to 2 byte (signed) aligned
* all branches to 2 byte aligned

### LD/ST

    | 0   | 1   | 2 3 4 | | 567 | 8 9 a | b c d | e | f |
    | RB2 | RA2 |  RT   | | 001 | 1  RA | 1  RB | 0 | 1 | fld
    | RA2 | RT2 |  RB   | | 001 | 1  RA | 1  RT | 1 | 1 | fst
    |     |     |  RT   | | 111 |  RA   |  RB   | 0 | 1 | ld
    |     |     |  RB   | | 111 |  RA   |  RT   | 1 | 1 | st

* elwidth overrides can set different widths

16 bit mode:

* F=1 is FLD, FST
* RA2 extends RA to 3 bits (MSB)
* RT2 extends RT to 3 bits (MSB)

10 bit mode:

* RA and RB are only 2 bit (0-3)
* for LD, RT is implicitly RB: "ld RT=RB, RA(RB)"
* for ST, there is no offset: "st RT, RA(0)"

### Arithmetic

    | 0 1 | 2 3 4 | | 567 | 8 9 a | b c d | e | f |
    |     |  RT   | | 010 | RB    | RA!=0 | 0 | 1 | add
    |     |  RT   | | 011 | RB    | RA!=0 | 0 | 1 | sub.
    |     |  RT   | | 010 | RB    | RA    | 1 | 1 | mul
    |     |  RT   | | 011 | RB    | 0 0 0 | 0 | 1 | neg.

10 bit mode:

* sub. default CR target is CR0
* for (RA|0) when RA=0 the input is a zero immediate,
  meaning that sub. becomes neg.
* RT is implicitly RB: "add RT(=RB), RA, RB"

### Logical

    | 0 1 | 2 3 4 | | 567 | 8 9 a | b c d | e | f |
    |     |  RT   | | 100 | RB    | RA!=0 | 0 | 1 | and
    |     |  RT   | | 100 | RB    | RA!=0 | 1 | 1 | nand
    |     |  RT   | | 101 | RB    | RA!=0 | 0 | 1 | or
    |     |  RT   | | 101 | RB    | RA!=0 | 1 | 1 | nor
    |     |  RT   | | 100 | RB    | 0 0 0 | 0 | 1 | exts
    |     |  RT   | | 100 | RB    | 0 0 0 | 1 | 1 | cntlz
    |     |  RT   | | 101 | RB    | 0 0 0 | 0 | 1 | popcnt
    |     |  RT   | | 101 | RB    | 0 0 0 | 1 | 1 | not

10 bit mode:

* for (RA|0) when RA=0 the input is a zero immediate,
  meaning that nor becomes not
* cntlz, popcnt, exts **not available** in 10-bit mode
* RT is implicitly RB: "and RT(=RB), RA, RB"

### Floating Point

    | 0 1 | 2 3 4 | | 567 | 8 9 a | b c d | e | f |
    |     |  RT   | | 011 | RB    | RA!=0 | 1 | 1 | fsub.
    |     |  RT   | | 110 | RB    | RA!=0 | 0 | 1 | fadd
    |     |  RT   | | 110 | RB    | RA!=0 | 1 | 1 | fmul
    |     |  RT   | | 011 | RB    | 0 0 0 | 1 | 1 | fneg.
    |     |  RT   | | 110 | RB    | 0 0 0 | 0 | 1 | fabs
    |     |  RT   | | 110 | RB    | 0 0 0 | 1 | 1 | fmr.

10 bit mode:

* fsub. fneg. and fmr. default target is CR1
* fmr. is **not available** in 10-bit mode

16 bit mode:

* fmr. copies RB to RT (and sets CR1)

### Condition Register

    | 0 1 2 3 | 4   | | 567 | 8 9 a | b c d e | f |
    | 0 0 0 0 | BF2 | | 001 | 1  BF | 0  BFA  | 1 | mcrf
    | 0 0 0 1 | BA2 | | 001 | 1  BA | 0  BB   | 1 | crnor
    | 0 1 0 0 | BA2 | | 001 | 1  BA | 0  BB   | 1 | crandc
    | 0 1 1 0 | BA2 | | 001 | 1  BA | 0  BB   | 1 | crxor
    | 0 1 1 1 | BA2 | | 001 | 1  BA | 0  BB   | 1 | crnand
    | 1 0 0 0 | BA2 | | 001 | 1  BA | 0  BB   | 1 | crand
    | 1 0 0 1 | BA2 | | 001 | 1  BA | 0  BB   | 1 | creqv
    | 1 1 0 1 | BA2 | | 001 | 1  BA | 0  BB   | 1 | crorc
    | 1 1 1 0 | BA2 | | 001 | 1  BA | 0  BB   | 1 | cror

10 bit mode:

* mcrf BF is only 2 bits which means the destination is only CR0-CR3
* CR operations: **not available** in 10-bit mode

16 bit mode:

* mcrf BF2 extends BF (in MSB) to 3 bits
* CR operations: destination register is same as BA.
* CR operations: only possible on CR0 and CR1

SV (Vector Mode):

* CR operations: greatly extended reach/range (useful for predicates)

### System

10/16-bit mode:

    | 0 1 | 2 3 4 | | 567 | 8 9 a | b c d | e | f |
    |     |       | | 010 | 0 0 0 | 0 0 0 | 0 | 1 | sc
    |     |       | | 010 | 0 0 1 | 0 0 0 | 0 | 1 | rfid

**not available** in 10-bit mode:

    | 0 1 2 3 | 4  | | 567 | 8 9 a | b c d e  | f |
    | 1 1 1 1 | 0  | | 001 | 1  00 | 0  RT    | 1 | mtlr
    | 1 1 1 1 | 0  | | 001 | 1  01 | 0  RT    | 1 | mtctr
    | 1 1 1 1 | 0  | | 001 | 1  10 | 0  RT    | 1 | mttar
    | 1 1 1 1 | 0  | | 001 | 1  11 | 0  RT    | 1 | mtcr
    | 1 1 1 1 | 1  | | 001 | 1  00 | 0  RA    | 1 | mflr
    | 1 1 1 1 | 1  | | 001 | 1  01 | 0  RA    | 1 | mfctr
    | 1 1 1 1 | 1  | | 001 | 1  10 | 0  RA    | 1 | mftar
    | 1 1 1 1 | 1  | | 001 | 1  11 | 0  RA    | 1 | mfcr

### Unallocated

    | 0 1 | 2 3 4 | | 567 | 8 9 a | b c d | e | f |
    |     |       | | 010 | 0 1 0 | 0 0 0 | 0 | 1 |
    |     |       | | 010 | 0 1 1 | 0 0 0 | 0 | 1 |
    |     |       | | 010 | 1 0 0 | 0 0 0 | 0 | 1 |
    |     |       | | 010 | 1 0 1 | 0 0 0 | 0 | 1 |
    |     |       | | 010 | 1 1 0 | 0 0 0 | 0 | 1 |
    |     |       | | 010 | 1 1 1 | 0 0 0 | 0 | 1 |

    | 0 1 2 3 | 4  | | 567 | 8 9 a | b c d e  | f |
    | 0 0 1 0 |    | | 001 | 1     | 0        | 1 |
    | 0 0 1 1 |    | | 001 | 1     | 0        | 1 |
    | 0 1 0 1 |    | | 001 | 1     | 0        | 1 |
    | 1 0 1 0 |    | | 001 | 1     | 0        | 1 |
    | 1 0 1 1 |    | | 001 | 1     | 0        | 1 |
    | 1 1 0 0 |    | | 001 | 1     | 0        | 1 |

