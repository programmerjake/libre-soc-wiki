# SV Context Propagation

[[sv/svp64]] context is 24 bits long, and Swizzle is 12.  These are enormous and not sustainable as far as power consumption is concerned.  Also, there is repetition of the same contexts to different instructions. An idea therefore is to add a level of indirection that allows these contexts to be applied to multiple instructions.

The basic principle is to have a special instruction in an svp64 context that takes a copy of the `RM[0..23]` bits, alongside a 21 bit suite that indicates which of the following 20 32 bit instructions will have that `RM` applied to them.  20 bits of the 21 bit suite are pushed into a 64 bit SPR, with the top 24 bits containing the `RM` and the other 40 being a shift register.  This may be done multiple times.

The 21 bit suite is inserted in bit-order from bit zero up until the last highest set bit (excluding that last bit).  For example: if the immediate contains 0b110 then the 40 bit shift register is pushed up by 2 bits, and its LSBs become 0b10.  Thus, the number of bits to be inserted is encoded within the 21 bits (using only 1 marker bit to do so).

| 0.5|6.7 | 8.10|11.31|  name   |
| -- | -- | --- | --- | ------- |
| OP | MM |     |     | ?-Form  |
| OP | 00 | idx | imm |         |

There are up to 8 possible 64 bit SPRs, the last (indexed 0b111) is always zeros.  Each is independently shifting its 40 bits down by one bit, except when a Context Propagation instruction or an svp64 encoded instruction is at the current PC.

Prior to the shift dropping the LSBs, any time the LSB of any one of the 7 Context SPRs is set, the 24 bit `RM` Context in that SPR is applied to the current 32 bit v3.0B instruction, making it an svp64 opcode instead of v3.0B.

If a situation would arise where more than one LSB is set (signalling an attempt to apply multiple contexts to the same instruction), an exception is raised.  Given that this may be detected when the value is inserted, an exception *MAY* be raised by the Context Propagation instruction rather than waiting until it reaches the LSBs.  As this is quite expensive (multi-way bit-comparison) it is optional.  However raising an illegal instruction should the conflict reach the LSBs is mandatory.

When the 40 bits of any one of the SPRs reaches zero the entire SPR is set to zero, and the entire SPR bank shuffles down (all SPRs above the one now zero move down one index position) so that at no time will there be an SPR containing zeros splitting up the other SPRs.  This allows a data-dependent fail-first copy of all SPRs to be used as a single instruction because the last SPR will always be zero.

These changes occur on a precise schedule: compilers should not have difficulties statically allocating the Context Propagation, as long as certain conventions are followed, such as avoidance of allowing the context to propagate through branches used by more than one incoming path, and variable-length loops.

Loops, clearly, because if the setup of the shift registers does not precisely match the number of instructions, the meaning of those instructions will change as the bits in the shift registers run out!  However if the loops are of fixed size and small enough (40 instructions maximum) then it is perfectly reasonable to insert repeated patterns into the shift registers, enough to cover all the loops.  Ordinarily however the use of the Context Propagation instructions should be inside the loop and it is the responsibility of the compiler and assembler writer to ensure that the shift registers reach zero before the loop jump point. 

# Swizzle Propagation

Swizzle Contexts follow the same schedule except that there is a mask for specifying to which registers the swizzle is to be applied, and there is onlyy 17 bit suite to indicate the instructions to which the swizzle applies.

| 0.5|6.7 | 8.10| 11.14 | 15.31 |  name   |
| -- | -- | --- | ----- | ----- | ------- |
| OP | MM |     | mask  |       | ?-Form  |
| OP | 01 | idx | mask  |  imm  |         |

Note however that only instructions which contain SUBVL!=1 cause the Swizxle SPRs to count down, and that consequently it is only svp64 encoded instructions 
to which this applies. *This includes Context-propagated ones!*

The mask is encoded as follows:

* bit 0 indicates that the dest reg is swizxled
* bit 1 indicates that src1 is swizzled
* bit 2 indicates that src2 is swizzled
* bit 3 indicates that src3 is swizzled
