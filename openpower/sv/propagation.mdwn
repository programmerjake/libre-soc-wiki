# SV Context Propagation

[[sv/svp64]] context is 24 bits long, and Swizzle is 12.  These are enormous and not sustainable as far as power consumption is concerned.  Also, there is repetition of the same contexts to different instructions. An idea therefore is to add a level of indirection that allows these contexts to be applied to multiple instructions.

The basic principle is to have a special instruction in an svp64 context that takes a copy of the `RM[0..23]` bits, alongside a 21 bit suite that indicates which of the following 20 32 bit instructions will have that `RM` applied to them.  An index is associated with each (up to four of them) such that multiple alternate contexts can be applied.  Under four 40 bit "stacks", 20 bits of the 21 bit suite are pushed into a given indexed stack. This may be done multiple times, with the upper bits being discarded.

If under a given index the `RM` is different, this indicates that the stavk is to be overwitten: rather than push the 40 bits upwards, the new 20 bits entirely overwrites the old 40 bits.  To set any of the eight stacks to zero the 20 bit value must be set to zero.

The 21 bit suite is inserted in bit-order from bit zero up until the last highest set bit (excluding that last bit).  For example: if the immediate contains 0b110 then the 40 bit shift register is pushed up by 2 bits, and its LSBs become 0b10.  Thus, the number of bits to be inserted is encoded within the 21 bits (using only 1 marker bit to do so).

| 0.5|6.8  | 9.10|11.31|  name   |
| -- | --- | --- | --- | ------- |
| OP | MMM |     |     | ?-Form  |
| OP | 000 | idx | imm |         |

There are 4 64 bit SPRs used for storing Context, and the data is stored as follows:

* Starting from the LSBs of the first SPR, the eight 24 bit `RM` are stored, wrapping round when crossing from one SPR to the next.  This covers 3*12 bytes which requires 1.5 64 bit SPRs to store QTY4 24 bit values.
* 
* Starting from half way through the 2nd SPR up to the MSB of the 4th the *indices* are stored 2x 40 bits for a total of 80 bits.

Thus when an `RM` is inserted the bits 

If a situation would arise where more than one LSB is set (signalling an attempt to apply multiple contexts to the same instruction), an exception is raised.  Given that this may be detected when the value is inserted, an exception is raised by the Context Propagation instruction.

The 80 bit shift register may be shuffled down

These changes occur on a precise schedule: compilers should not have difficulties statically allocating the Context Propagation, as long as certain conventions are followed, such as avoidance of allowing the context to propagate through branches used by more than one incoming path, and variable-length loops.

Loops, clearly, because if the setup of the shift registers does not precisely match the number of instructions, the meaning of those instructions will change as the bits in the shift registers run out!  However if the loops are of fixed size and small enough (40 instructions maximum) then it is perfectly reasonable to insert repeated patterns into the shift registers, enough to cover all the loops.  Ordinarily however the use of the Context Propagation instructions should be inside the loop and it is the responsibility of the compiler and assembler writer to ensure that the shift registers reach zero before the loop jump point. 

# Swizzle Propagation

Swizzle Contexts follow the same schedule except that there is a mask for specifying to which registers the swizzle is to be applied, and there is only 17 bit suite to indicate the instructions to which the swizzle applies.

| 0.5|6.7 | 8.10| 11.14 | 15.31 |  name   |
| -- | -- | --- | ----- | ----- | ------- |
| OP | MM |     | mask  |       | ?-Form  |
| OP | 01 | idx | mask  |  imm  |         |

Note however that only instructions which contain SUBVL!=1 cause the Swizxle SPRs to count down, and that consequently it is only svp64 encoded instructions 
to which this applies. *This includes Context-propagated ones!*

The mask is encoded as follows:

* bit 0 indicates that the dest reg is swizzled
* bit 1 indicates that src1 is swizzled
* bit 2 indicates that src2 is swizzled
* bit 3 indicates that src3 is swizzled
