# SV Context Propagation

[[sv/svp64]] context is 24 bits long, and Swizzle is 12.  These are enormous and not sustainable as far as power consumption is concerned.  Also, there is repetition of the same contexts to different instructions. An idea therefore is to add a level of indirection that allows these contexts to be applied to multiple instructions.

The basic principle is to have a suite of 40 indices in a shift register that indicate one of seven `RM[0:23]` prefixes shall be applied to upcoming 32 bit v3.0B instructions.  The Least Significant Index in the shift register is the one that is applied.  One of those indices is 0b000 which indicates "no prefix applied".

A special instruction in an svp64 context takes a copy of the `RM[0..23]` bits, alongside a 21 bit suite that indicates up to 20 32 bit instructions will have that `RM` applied to them, as well as an index to associate with the `RM`.  If there are already indices set within the shift register then the new entries are placed after the end of the highest-indexed one.

| 0.5|6.8  | 9.10|11.31|  name   |
| -- | --- | --- | --- | ------- |
| OP | MMM |     |     | ?-Form  |
| OP | 000 | idx | imm |         |

There are 4 64 bit SPRs used for storing Context, and the data is stored as follows:

* Starting from the LSBs of the first SPR, the eight 24 bit `RM` are stored, wrapping round when crossing from one SPR to the next.  This covers 3*8 bytes which requires 3 64 bit SPRs to store QTY8 24 bit values.
* Starting from the LSB of the 4th SPR up to the MSB of the 8th the *indices* are stored 3x 40 bits for a total of 160 bits.

Thus when an `RM` is inserted the bits 

If a situation would arise where more than one LSB is set (signalling an attempt to apply multiple contexts to the same instruction), an exception is raised.  Given that this may be detected when the value is inserted, an exception is raised by the Context Propagation instruction.

The 80 bit shift register may be shuffled down

These changes occur on a precise schedule: compilers should not have difficulties statically allocating the Context Propagation, as long as certain conventions are followed, such as avoidance of allowing the context to propagate through branches used by more than one incoming path, and variable-length loops.

Loops, clearly, because if the setup of the shift registers does not precisely match the number of instructions, the meaning of those instructions will change as the bits in the shift registers run out!  However if the loops are of fixed size and small enough (40 instructions maximum) then it is perfectly reasonable to insert repeated patterns into the shift registers, enough to cover all the loops.  Ordinarily however the use of the Context Propagation instructions should be inside the loop and it is the responsibility of the compiler and assembler writer to ensure that the shift registers reach zero before the loop jump point. 

# Swizzle Propagation

Swizzle Contexts follow the same schedule except that there is a mask for specifying to which registers the swizzle is to be applied, and there is only 17 bit suite to indicate the instructions to which the swizzle applies.

| 0.5|6.7 | 8.10| 11.14 | 15.31 |  name   |
| -- | -- | --- | ----- | ----- | ------- |
| OP | MM |     | mask  |       | ?-Form  |
| OP | 01 | idx | mask  |  imm  |         |

Note however that only instructions which contain SUBVL!=1 cause the Swizxle SPRs to count down, and that consequently it is only svp64 encoded instructions 
to which this applies. *This includes Context-propagated ones!*

The mask is encoded as follows:

* bit 0 indicates that the dest reg is swizzled
* bit 1 indicates that src1 is swizzled
* bit 2 indicates that src2 is swizzled
* bit 3 indicates that src3 is swizzled
