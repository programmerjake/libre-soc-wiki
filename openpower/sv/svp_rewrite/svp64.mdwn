# Links

* <http://lists.libre-soc.org/pipermail/libre-soc-dev/2020-December/001498.html>>
* [[svp64/discussion]]
* <http://lists.libre-soc.org/pipermail/libre-soc-dev/2020-December/001650.html>
* <https://bugs.libre-soc.org/show_bug.cgi?id=550>

# Rewrite of SVP64 for OpenPower ISA v3.1

The plan is to create an encoding for SVP64, then to create an encoding
for SVP48, then to reorganize them both to improve field overlap,
reducing the amount of decoder hardware necessary.

All bit numbers are in MSB0 form (the bits are numbered from 0 at the MSB
and counting up as you move to the LSB end). All bit ranges are inclusive
(so `4:6` means bits 4, 5, and 6).

64-bit instructions are split into two 32-bit words, the prefix and the
suffix. The prefix always comes before the suffix in PC order.

| 0:5    | 6:31         | 0:31         |
|--------|--------------|--------------|
| EXT01  | v3.1B Prefix | v3.1B Suffix |

svp64 fits into the "reserved" portions of the v3.1B prefix, making it possible for svp64, v3.0B (or v3.1B including 64 bit prefixed) instructions  to co-exist in the same binary without conflict.

# Definition of Reserved in this spec.

For the new fields added in SVP64, instructions that have any of their
fields set to a reserved value must cause an illegal instruction trap,
to allow emulation of future instruction sets.

This is unlike OpenPower ISA v3.1, which in many instances does not require a trap if reserved fields are nonzero.

# Identity Behaviour

SVP64 is designed so that when the prefix is all zeros, and
 VL=1, no effect or
influence occurs (no augmentation) such that all standard OpenPOWER
v3.0/1B instructions covered by the prefix are "unaltered". This is termed `scalar identity behaviour` (based on the mathematical definition for "identity", as in, "identity matrix" or better "identity transformation").

Note that this is completely different from when VL=0.  VL=0 turns all operations under its influence into `nops` (regardless of the prefix)
 whereas when VL=1 and the SV prefix is all zeros, the operation simply acts as if SV had not been applied at all to the instruction  (an "identity operation").



# Register Naming and size

SV Registers are simply the INT, FP and CR register files extended
linearly to larger sizes; SV Vectorisation iterates sequentially through these registers.

Where the integer regfile in standard scalar
OpenPOWER v3.0B/v3.1B is r0 to r31, SV extends this as r0 to r127.
Likewise FP registers are extended to 128 (fp0 to fp127), and CRs are
extended to 64 entries, CR0 thru CR63.

The names of the registers therefore reflects a simple linear extension
of the OpenPOWER v3.0B / v3.1B register naming, and in hardware this
would be reflected by a linear increase in the size of the underlying
SRAM used for the regfiles.

Note: when an EXTRA field (defined below) is zero, SV is deliberately designed
so that the register fields are identical to as if SV was not in effect
i.e. under these circumstances (EXTRA=0) the register field names RA,
RB etc. are interpreted and treated as v3.0B / v3.1B scalar registers.  This is part of
`scalar identity behaviour` described above.

## Future expansion.

With the way that EXTRA fields are defined and applied to register fields,
future versions of SV may involve 256 or greater registers.  To accommodate 256 registers, numbering of Vectors will simply shift up by one bit, without
requiring additional prefix bits.  Backwards binary compatibility may be achieved with a PCR bit (Program Compatibility Register).  Beyond this, further discussion is out of scope for this version of svp64.

# Remapped Encoding (`RM[0:23]`)

To allow relatively easy remapping of which portions of the Prefix Opcode
Map are used for SVP64 without needing to rewrite a large portion of the
SVP64 spec, a mapping is defined from the OpenPower v3.1 prefix bits to
a new 24-bit Remapped Encoding denoted `RM[0]` at the MSB to `RM[23]`
at the LSB.

The mapping from the OpenPower v3.1 prefix bits to the Remapped Encoding
is defined in the Prefix Fields section.

## Prefix Opcode Map (64-bit instruction encoding) (prefix bits 6:11)

shows both PowerISA v3.1 instructions as well as new SVP instructions;
empty spaces are yet-to-be-allocated Illegal Instructions.  The original
table in the v3.1B OpenPOWER ISA Spec is on p1350, Table 12.

| 6:11 | ---000 | ---001 | ---010 | ---011 | ---100 | ---101 | ---110 | ---111 |
|------|--------|--------|--------|--------|--------|--------|--------|--------|
|000---| 8LS    | 8LS    | 8LS    | 8LS    | 8LS    | 8LS    | 8LS    | 8LS    |
|001---|        |        |        |        |        |        |        |        |
|010---| 8RR    |        |        |        | `SVP64`| `SVP64`| `SVP64`| `SVP64`|
|011---|        |        |        |        | `SVP64`| `SVP64`| `SVP64`| `SVP64`|
|100---| MLS    | MLS    | MLS    | MLS    | MLS    | MLS    | MLS    | MLS    |
|101---|        |        |        |        |        |        |        |        |
|110---| MRR    |        |        |        | `SVP64`| `SVP64`| `SVP64`| `SVP64`|
|111---|        | MMIRR  |        |        | `SVP64`| `SVP64`| `SVP64`| `SVP64`|

## Prefix Fields

To "activate" svp64, fields within the v3.1B Prefix Opcode Map are set
(see Prefix Opcode Map, above), leaving 24 bits "free" for use by SV.

| Name       | Bits    | Value | Description                    |
|------------|---------|-------|--------------------------------|
| EXT01      | `0:5`   | `1`   | Indicates Prefixed 64-bit      |
| `RM[0]`    | `6`     |       | Bit 0 of Remapped Encoding     |
| SVP64_7    | `7`     | `1`   | Indicates this is SVP64        |
| `RM[1]`    | `8`     |       | Bit 1 of Remapped Encoding     |
| SVP64_9    | `9`     | `1`   | Indicates this is SVP64        |
| `RM[2:23]` | `10:31` |       | Bits 2-23 of Remapped Encoding |

Laid out bitwise, this is as follows, showing how the 32-bits of the prefix
are constructed:

| 0:5    | 6     | 7 | 8     | 9 | 10:31    |
|--------|-------|---|-------|---|----------|
| EXT01  | RM    | 1 | RM    | 1 | RM       |
| 000001 | RM[0] | 1 | RM[1] | 1 | RM]2:23] |

Following the prefix will be the suffix: this is simply a 32-bit v3.0B / v3.1B
instruction.  That instruction is "prefixed" with the SV context: the
Remapped Encoding field (RM).

# Remapped Encoding Fields

Shows all fields in the Remapped Encoding `RM[0:23]` for all instruction
variants.  There are two categories:  Single and Twin Predication.
Due to space considerations further subdivision of Single Predication
is based on whether the number of src operands is 2 or 3.


* `RM-1P-3S1D` Single Predication dest/src1/2/3, applies to 4-operand instructions (fmadd, isel, madd).
* `RM-1P-2S1D` Single Predication dest/src1/2 applies to 3-operand instructions (src1 src2 dest)
* `RM-2P-1S1D` Twin Predication (src=1, dest=1)
* `RM-2P-2S1D` Twin Predication (src=2, dest=1) primarily for LDST (Indexed)
* `RM-2P-1S2D` Twin Predication (src=1, dest=2) primarily for LDST Update

## RM-1P-3S1D

| Field Name | Field bits | Description                            |
|------------|------------|----------------------------------------|
| MASK\_KIND    | `0`        | Execution Mask Kind                 |
| MASK          | `1:3`      | Execution Mask                      |
| ELWIDTH       | `4:5`      | Element Width                       |
| SUBVL         | `6:7`      | Sub-vector length                   |
| Rdest\_EXTRA2 | `8:9`   | extends Rdest (R\*\_EXTRA2 Encoding)   |
| Rsrc1\_EXTRA2 | `10:11` | extends Rsrc1 (R\*\_EXTRA2 Encoding)   |
| Rsrc2\_EXTRA2 | `12:13` | extends Rsrc2 (R\*\_EXTRA2 Encoding)   |
| Rsrc3\_EXTRA2 | `14:15` | extends Rsrc3 (R\*\_EXTRA2 Encoding)   |
| reserved      | `16`    | reserved                               |
| MODE          | `19:23` | changes Vector behaviour               |

## RM-1P-2S1D

| Field Name | Field bits | Description                               |
|------------|------------|-------------------------------------------|
| MASK\_KIND    | `0`     | Execution Mask Kind                       |
| MASK          | `1:3`   | Execution Mask                            |
| ELWIDTH       | `4:5`   | Element Width                             |
| SUBVL         | `6:7`   | Sub-vector length                         |
| Rdest\_EXTRA3 | `8:10`  | extends Rdest  |
| Rsrc1\_EXTRA3 | `11:13` | extends Rsrc1  |
| Rsrc2\_EXTRA3 | `14:16` | extends Rsrc3    |
| ELWIDTH_SRC   | `17:18` | Element Width for Source      |
| MODE          | `19:23` | changes Vector behaviour                  |

These are for 2 operand 1 dest instructions, such as `add RT, RA,
RB`. However also included are unusual instructions with an implicit dest
that is identical to its src reg, such as `rlwinmi`.

Normally, with instructions such as `rlwinmi`, the scalar v3.0B ISA would not have sufficient bit fields to allow
an alternative destination.  With SV however this becomes possible.
Therefore, the fact that the dest is implicitly also a src should not
mislead: due to the *prefix* they are different SV regs.

* `rlwimi RA, RS, ...`
* Rsrc1_EXTRA3 applies to RS as the first src
* Rsrc2_EXTRA3 applies to RA as the secomd src
* Rdest_EXTRA3 applies to RA to create an **independent** dest.

With the addition of the EXTRA bits, the three registers
each may be *independently* made vector or scalar, and be independently
augmented to 7 bits in length.

Note that if ELWIDTH != ELWIDTH_SRC this may result in reduced performance or increased latency in some implementations due to lane-crossing. 

## RM-2P-1S1D

| Field Name | Field bits | Description                                 |
|------------|------------|----------------------------|
| MASK_KIND  | `0`        | Execution Mask Kind                          |
| MASK       | `1:3`      | Execution Mask                               |
| ELWIDTH    | `4:5`      | Element Width                                |
| SUBVL      | `6:7`      | Sub-vector length                           |
| Rdest_EXTRA3 | `8:10`     | extends Rdest                     |
| Rsrc1_EXTRA3 | `11:13`    | extends Rsrc1                      |
| MASK_SRC     | `14:16`    | Execution Mask for Source     |
| ELWIDTH_SRC  | `17:18`    | Element Width for Source      |
| MODE         | `19:23`    | changes Vector behaviour                       |

Note that if ELWIDTH != ELWIDTH_SRC this may result in reduced performance or increased latency in some implementations due to lane-crossing. 

## RM-2P-2S1D/1S2D

The primary purpose for this encoding is for Twin Predication on LOAD
and STORE operations.  see [[sv/ldst]] for detailed anslysis.

RM-2P-2S1D:

| Field Name | Field bits | Description                                 |
|------------|------------|----------------------------|
| MASK_KIND  | `0`        | Execution Mask Kind                          |
| MASK       | `1:3`      | Execution Mask                               |
| ELWIDTH    | `4:5`      | Element Width                                |
| SUBVL      | `6:7`      | Sub-vector length                           |
| Rdest_EXTRA2 | `8:9`   | extends Rdest (R\*\_EXTRA2 Encoding)   |
| Rsrc1_EXTRA2 | `10:11` | extends Rsrc1 (R\*\_EXTRA2 Encoding)   |
| Rsrc2_EXTRA2 | `12:13` | extends Rsrc2 (R\*\_EXTRA2 Encoding)   |
| MASK_SRC     | `14:16`    | Execution Mask for Source     |
| ELWIDTH_SRC  | `17:18`    | Element Width for Source      |
| MODE         | `19:23`    | changes Vector behaviour                       |

Note that for 1S2P the EXTRA2 dest and src names are switched (Rsrc_EXTRA2
is in bits 8:9, Rdest1_EXTRA2 in 10:11)

Note also that LD with update indexed, which takes 2 src and 2 dest
(e.g. `lhaux RT,RA,RB`), does not have room for 4 registers and also
Twin Predication.  therefore these are treated as RM-2P-2S1D and the
src spec for RA is also used for the same RA as a dest.

Note that if ELWIDTH != ELWIDTH_SRC this may result in reduced performance or increased latency in some implementations due to lane-crossing. 

# Mode

Mode is an augmentation of SV behaviour.  Some of these alterations are element-based (saturation), others involve post-analysis (predicate result) and others are Vector-based (mapreduce, fail-on-first).

These are the modes:

* **normal** mode is straight vectorisation.  no augmentations: the vector comprises an array of independently created results.
* **ffirst** or data-dependent fail-on-first: see separate section.  the vector may be truncated depending on certain criteria.
  *VL is altered as a result*.
* **sat mode** or saturation: clamps each elemrnt result to a min/max rather than overflows / wraps.  allows signed and unsigned clamping. 
* **reduce mode**. a mapreduce is performed.  the result is a scalar.  a result vector however is required, as the upper elements may be used to store intermediary computations.  the result of the mapreduce is in the first element with a nonzero predicate bit.  see separate section below.
  note that there are comprehensive caveats when using this mode.
* **pred-result** will test the result (CR testing selects a bit of CR and inverts it, just like branch testing) and if the test fails it is as if the predicate bit was zero.  When Rc=1 the CR element however is still stored in the CR regfile, even if the test failed.  This scheme does not apply to crops (crand, cror).  See appendix for details.

Note that ffirst and reduce modes are not anticipated to be high-performance in some implementations.  ffirst due to interactions with VL, and reduce due to it requiring additional operations to produce a result.  normal, saturate and pred-result are however independent and may easily be parallelised to give high performance, regardless of the value of VL.

The Mode table is laid out as follows:

| 0-1 |  2  |  3   4  |  description              |
| --- | --- |---------|-------------------------- |
| 00  |   0 |  sz  dz | normal mode                      |
| 00  |   1 | sz CRM  | reduce mode (mapreduce), SUBVL=1 |
| 00  |   1 | SVM CRM | subvector reduce mode, SUBVL>1   |
| 01  | inv | CR-bit  | Rc=1: ffirst CR sel              |
| 01  | inv | sz   dz |  Rc=0: ffirst z/nonz |
| 10  |   N | sz   dz |  sat mode: N=0/1 u/s |
| 11  | inv | CR-bit  |  Rc=1: pred-result CR sel |
| 11  | inv | sz   dz |  Rc=0: pred-result z/nonz |

Fields:

* **sz / dz**  if predication is enabled will put zeros into the dest (or as src in the case of twin pred) when the predicate bit is zero.  otherwise the element is ignored or skipped, depending on context.
* **inv CR bit** just as in branches (BO) these bits allow testing of a CR bit and whether it is set (inv=0) or unset (inv=1)
* **CRM** affects the CR on reduce mode when Rc=1
* **SVM** sets "subvector" reduce mode
* **N** sets signed/unsigned saturation.

# R\*\_EXTRA2 and R\*\_EXTRA3 Encoding

EXTRA is the means by which two things are achieved:

1. Registers are marked as either Vector *or Scalar*
2. Register field numbers (limited typically to 5 bit)
   are extended in range, both for Scalar and Vector.

In the following tables register numbers are constructed from the
standard v3.0B / v3.1B 32 bit register field (RA, FRA) and the EXTRA2
or EXTRA3 field from the SV Prefix.  The prefixing is arranged so that
interoperability between prefixing and nonprefixing of scalar registers
is direct and convenient (when the EXTRA field is all zeros).

A pseudocode algorithm explains the relationship, for INT/FP (see separate section for CRs)

    if extra3_mode:
        spec = EXTRA3
    else:
        spec = EXTRA2 << 1 # same as EXTRA3, shifted
    if spec[2]: # vector
         return (RA << 2) | spec[0:1]
    else:         # scalar
         return (spec[0:1] << 5) | RA

## INT/FP EXTRA3

alternative which is understandable and, if EXTRA3 is zero, maps to
"no effect" (scalar OpenPOWER ISA field naming).  also, these are the
encodings used in the original SV Prefix scheme.  the reason why they
were chosen is so that scalar registers in v3.0B and prefixed scalar
registers have access to the same 32 registers.

| R\*\_EXTRA3 | Mode | Range | MSB downto LSB |
|-----------|-------|---------------|---------------------|
| 000       | Scalar | `r0-r31` | `0b00 RA`      |
| 001       | Scalar | `r32-r63` | `0b01 RA`      |
| 010       | Scalar | `r64-r95` | `0b10 RA`      |
| 011       | Scalar | `r96-r127` | `0b11 RA`      |
| 100       | Vector | `r0-r124` | `RA 0b00`      |
| 101       | Vector | `r1-r125` | `RA 0b01`      |
| 110       | Vector | `r2-r126` | `RA 0b10`      |
| 111       | Vector | `r3-r127` | `RA 0b11`      |

## INT/FP EXTRA2

alternative which is understandable and, if EXTRA2 is zero will map to
"no effect" i.e Scalar OpenPOWER register naming:

| R\*\_EXTRA2 | Mode | Range | MSB down to LSB |
|-----------|-------|---------------|---------------------|
| 00       | Scalar | `r0-r31` | `0b00 RA`                |
| 01       | Scalar | `r32-r63` | `0b01 RA`      |
| 10       | Vector | `r0-r124` | `RA 0b00`      |
| 11       | Vector | `r2-r126` | `RA 0b10`   |

## CR EXTRA3

CR encoding is essentially the same but made more complex due to CRs being bit-based.  See separate section for explanation and pseudocode.

 Encoding shown MSB down to LSB

| R\*\_EXTRA3 | Mode | 7..5    | 4..2    | 1..0    |
|-------------|------|---------| --------|---------|
| 000       | Scalar | 0b000   | BA[4:2] | BA[1:0] |
| 001       | Scalar | 0b001   | BA[4:2] | BA[1:0] |
| 010       | Scalar | 0b010   | BA[4:2] | BA[1:0] |
| 011       | Scalar | 0b011   | BA[4:2] | BA[1:0] |
| 100       | Vector | BA[4:2] | 0b000   | BA[1:0] |
| 101       | Vector | BA[4:2] | 0b010   | BA[1:0] |
| 110       | Vector | BA[4:2] | 0b100   | BA[1:0] |
| 111       | Vector | BA[4:2] | 0b110   | BA[1:0] |

## CR EXTRA2

CR encoding is essentially the same but made more complex due to CRs being bit-based.  See separate section for explanation and pseudocode.

Encoding shown MSB down to LSB

| R\*\_EXTRA2 | Mode   | 7..5    | 4..2    | 1..0    |
|-------------|--------|---------|---------|---------|
| 00          | Scalar | 0b000   | BA[4:2] | BA[1:0] |
| 01          | Scalar | 0b001   | BA[4:2] | BA[1:0] |
| 10          | Vector | BA[4:2] | 0b000   | BA[1:0] |
| 11          | Vector | BA[4:2] | 0b100   | BA[1:0] |

# ELWIDTH Encoding

Default behaviour is set to 0b00 so that zeros follow the convention of
"npt doing anything".  In this case it means that elwidth overrides
are not applicable.  Thus if a 32 bit instruction operates on 32 bit,
`elwidth=0b00` specifies that this behaviour is unmodified.  Likewise
when a processor is switched from 64 bit to 32 bit mode, `elwidth=0b00`
states that, again, the behaviour is not to be modified.

Only when elwidth is nonzero is the element width overridden to the
explicitly required value.

## Elwidth for Integers:

| Value | Mnemonic       | Description                        |
|-------|----------------|------------------------------------|
| 00    | DEFAULT        | default behaviour for operation    |
| 01    | `ELWIDTH=b`    | Byte: 8-bit integer                  |
| 10    | `ELWIDTH=h`    | Halfword: 16-bit integer             |
| 11    | `ELWIDTH=w`    | Word: 32-bit integer                 |

## Elwidth for FP Registers:

| Value | Mnemonic       | Description                        |
|-------|----------------|------------------------------------|
| 00    | DEFAULT        | default behaviour for FP operation     |
| 01    | `ELWIDTH=bf16` | Reserved for `bf16` |
| 10    | `ELWIDTH=f16`  | 16-bit IEEE 754 Half floating-point   |
| 11    | `ELWIDTH=f32`  | 32-bit IEEE 754 Single floating-point  |

Note:
[`bf16`](https://en.wikipedia.org/wiki/Bfloat16_floating-point_format)
is reserved for a future implementation of SV

## Elwidth for CRs:

TODO, important, particularly for crops, mfcr and mtcr, what elwidth
even means.  instead it may be possible to use the bits as extra indices
(EXTRA6) to access the full 64 CRs.  TBD, several ideas

The actual width of the CRs cannot be altered: they are 4 bit.  Also,
for Rc=1 operations that produce a result (in RT or FRT) and corresponding CR, it is
the INT/FP result to which the elwidth override applies, *not* the CR.
This therefore inherently places Rc=1 operations firmly out of scope as far as a "meaning" for elwidth on CRs is concerned.

As mentioned TBD, this leaves crops etc. to have a meaning defined for
elwidth, because these ops are pure explicit CR based.

Examples: mfxm may take the extra bits and use them as extra mask bits.

# SUBVL Encoding

the default for SUBVL is 1 and its encoding is 0b00 to indicate that
SUBVL is effectively disabled (a SUBVL for-loop of only one element). this
lines up in combination with all other "default is all zeros" behaviour.

| Value | Mnemonic  | Subvec  | Description            |
|-------|-----------|---------|------------------------|
| 00    | `SUBVL=1` | single  | Sub-vector length of 1 |
| 01    | `SUBVL=2` | vec2    | Sub-vector length of 2 |
| 10    | `SUBVL=3` | vec3    | Sub-vector length of 3 |
| 11    | `SUBVL=4` | vec4    | Sub-vector length of 4 |

The SUBVL encoding value may be thought of as an inclusive range of a
sub-vector.  SUBVL=2 represents a vec2, its encoding is 0b01, therefore
this may be considered to be elements 0b00 to 0b01 inclusive.

# MASK/MASK_SRC & MASK_KIND Encoding

One bit (`MASKMODE`) indicates the mode: CR or Int predication.   The two
types may not be mixed.

Special note: to get default behaviour (SV disabled) this field must
be set to zero in combination with Integer Predication also being set
to 0b000. this has the effect of enabling "all 1s" in the predicate
mask, which is equivalent to "not having any predication at all"
and consequently, in combination with all other default zeros, fully
disables SV.

| Value | Description                                          |
|-------|------------------------------------------------------|
| 0     | MASK/MASK_SRC are encoded using Integer Predication  |
| 1     | MASK/MASK_SRC are encoded using CR-based Predication |

Integer Twin predication has a second set of 3 bits that uses the same
encoding thus allowing either the same register (r3 or r10) to be used
for both src and dest, or different regs (one for src, one for dest).

Likewise CR based twin predication has a second set of 3 bits, allowing
a different test to be applied.

## Integer Predication (MASK_KIND=0)

When the predicate mode bit is zero the 3 bits are interpreted as below.
Twin predication has an identical 3 bit field similarly encoded.

| Value | Mnemonic | Element `i` enabled if:      |
|-------|----------|------------------------------|
| 000   | ALWAYS   | predicate effectively all 1s |
| 001   | 1 << R3  | `i == R3`                    |
| 010   | R3       | `R3 & (1 << i)` is non-zero  |
| 011   | ~R3      | `R3 & (1 << i)` is zero      |
| 100   | R10      | `R10 & (1 << i)` is non-zero |
| 101   | ~R10     | `R10 & (1 << i)` is zero     |
| 110   | R30      | `R30 & (1 << i)` is non-zero |
| 111   | ~R30     | `R30 & (1 << i)` is zero     |

## CR-based Predication (MASK_KIND=1)

When the predicate mode bit is one the 3 bits are interpreted as below.
Twin predication has an identical 3 bit field similarly encoded

| Value | Mnemonic | Element `i` is enabled if     |
|-------|----------|--------------------------|
| 000   | lt       | `CR[offs+i].LT` is set   |
| 001   | nl/ge    | `CR[offs+i].LT` is clear |
| 010   | gt       | `CR[offs+i].GT` is set   |
| 011   | ng/le    | `CR[offs+i].GT` is clear |
| 100   | eq       | `CR[offs+i].EQ` is set   |
| 101   | ne       | `CR[offs+i].EQ` is clear |
| 110   | so/un    | `CR[offs+i].FU` is set   |
| 111   | ns/nu    | `CR[offs+i].FU` is clear |

CR based predication.  TODO: select alternate CR for twin predication? see
[[discussion]]  Overlap of the two CR based predicates must be taken
into account, so the starting point for one of them must be suitably
high, or accept that for twin predication VL must not exceed the range
where overlap will occur, *or* that they use the same starting point
but select different *bits* of the same CRs

`offs` is defined as CR32 (4x8) so as to mesh cleanly with Vectorised Rc=1 operations (see below).  Rc=1 operations start from CR8 (TBD).

# Appendix

## XER, SO and other global flags

Vector systems are expected to be high performance.  This is achieved
through parallelism, which requires that elements in the vector be
independent.  XER SO and other global "accumulation" flags (CR.OV) cause
Read-Write Hazards on single-bit global resources, having a significant
detrimental adverse effect.

Consequently in SV, XER.SO and CR.OV behaviour is disregarded.  XER is
simply neither read nor written.  This includes when `scalar identity behaviour` occurs.  If precise OpenPOWER v3.0/1 scalar behaviour is desired then OpenPOWER v3.0/1 instructions should be used without an SV Prefix.

An interesting side-effect of this decision is that the OE flag is now free for other uses when SV Prefixing is used.

Regarding XER.CA: this does not fit either: it was designed for a scalar ISA. Instead, both carry-in and carry-out go into the CR.so bit of a given Vector element.  This provides a means to perform large parallel batches of Vectorised carry-capable additions.

## v3.0B/v3.1B relevant instructions

SV is primarily designed for use as an efficient hybrid 3D GPU / VPU / CPU ISA.

As mentioned above, OE=1 is not applicable in SV, freeing this bit for alternative uses.  Additionally, Vectorisation of the VSX SIMD system likewise makes no sense whatsoever. SV *replaces* VSX and provides, at the very minimum, predication (which VSX was designed without).  Thus all VSX Major Opcodes - all of them - are "unused" and must raise illegal instruction exceptions in SV Prefix Mode.

Likewise, `lq` (Load Quad), and Load/Store Multiple make no sense to have because they are not only provided by SV, the SV alternatives may be predicated as well, making them far better suited to use in function calls and context-switching.

This leaves several Major Opcodes free for use by SV to fit alternative instructions: Vector Product, Vector Normalise, [[sv/mv.swizzle]], Texture LD/ST operations, and others critical to an efficient, effective 3D GPU and VPU ISA. With such instructions being included as standard in other commercially-successful GPU ISAs it is likewise critical that a 3D GPU/VPU based on svp64 also have such instructions.

Note however that svp64 is stand-alone and is in no way critically dependent on the existence or provision of 3D GPU or VPU instructions. These should be considered extensions, and their discussion and specification is out of scope for this document.

Note, again: this is *only* under svp64 prefixing.  Standard v3.0B / v3.1B is *not* altered by svp64.
## Twin Predication

This is a novel concept that allows predication to be applied to a single
source and a single dest register.  The following types of traditional
Vector operations may be encoded with it, *without requiring explicit
opcodes to do so*

* VSPLAT (a single scalar distributed across a vector)
* VEXTRACT (like LLVM IR [`extractelement`](https://releases.llvm.org/11.0.0/docs/LangRef.html#extractelement-instruction))
* VINSERT (like LLVM IR [`insertelement`](https://releases.llvm.org/11.0.0/docs/LangRef.html#insertelement-instruction))
* VCOMPRESS (like LLVM IR [`llvm.masked.compressstore.*`](https://releases.llvm.org/11.0.0/docs/LangRef.html#llvm-masked-compressstore-intrinsics))
* VEXPAND (like LLVM IR [`llvm.masked.expandload.*`](https://releases.llvm.org/11.0.0/docs/LangRef.html#llvm-masked-expandload-intrinsics))

Those patterns (and more) may be applied to:

* mv (the usual way that V\* ISA operations are created)
* exts\* sign-extension
* rwlinm and other RS-RA shift operations (**note**: excluding
  those that take RA as both a src and dest. These are not
  1-src 1-dest, they are 2-src, 1-dest)
* LD and ST (treating AGEN as one source)
* FP fclass, fsgn, fneg, fabs, fcvt, frecip, fsqrt etc.
* Condition Register ops mfcr, mtcr and other similar

This is a huge list that creates extremely powerful combinations,
particularly given that one of the predicate options is `(1<<r3)`

Additional unusual capabilities of Twin Predication include a back-to-back
version of VCOMPRESS-VEXPAND which is effectively the ability to do 
sequentially ordered multiple VINSERTs.  The source predicate selects a 
sequentially ordered subset of elements to be inserted; the destination predicate specifies the sequentially ordered recipient locations.

## Rounding, clamp and saturate

One of the issues with vector ops is that in integer DSP ops for example
in Audio the operation must clamp or saturate rather than overflow or
ignore the upper bits and become a modulo operation.  This for Audio
is extremely important, also to provide an indicator as to whether
saturation occurred.  see  [[av_opcodes]].

To help ensure that audio quality is not compromised by overflow,
"saturation" is provided, as well as a way to detect when saturation
occurred (Rc=1). When Rc=1 there will be a *vector* of CRs, one CR per
element in the result (Note: this is different from VSX which has a
single CR per block).

When N=0 the result is saturated to within the maximum range of an
unsigned value.  For integer ops this will be 0 to 2^elwidth-1. Similar
logic applies to FP operations, with the result being saturated to
maximum rather than returning INF.

When N=1 the same occurs except that the result is saturated to the min
or max of a signed result.

When Rc=1, the CR "overflow" bit is set on the CR associated with the
element, to indicate whether saturation occurred.  Note that due to
the hugely detrimental effect it has on parallel processing, XER.SO is
**ignored** completely and is **not** brought into play here.  The CR
overflow bit is therefore simply set to zero if saturation did not occur,
and to one if it did.

Note also that saturate on operations that produce a carry output are prohibited due to the conflicting use of the CR.so bit for storing if saturation occurred.

Post-analysis of the Vector of CRs to find out if any given element hit
saturation may be done using a mapreduced CR op (cror), or by using the
new crweird instruction, transferring the relevant CR bits to a scalar
integer and testing it for nonzero.  see [[sv/cr_int_predication]]

Note that the operation takes place at the maximum bitwidth (max of src and dest elwidth) and that truncation occurs to the range of the dest elwidth.

## Reduce mode

1. limited to single predicated dual src operations (add RT, RA, RB).
   triple source operations are prohibited (fma).
2. limited to operations that make sense.  divide is excluded, as is
   subtract (X - Y - Z produces different answers depending on the order)
   and asymmetric CRops (crandc, crorc). sane  operations:
   multiply, min/max, add, logical bitwise OR, most other CR ops.
   operations that do have the same source and dest register type are
   also excluded (isel, cmp). operations involving carry or overflow
   (XER.CA / OV) are also prohibited.
3. the destination is a vector but the result is stored, ultimately,
   in the first nonzero predicated element.  all other nonzero predicated
   elements are undefined. *this includes the CR vector* when Rc=1
4. implementations may use any ordering and any algorithm to reduce
   down to a single result.  However it must be equivalent to a straight
   application of mapreduce.  The destination vector (except masked out
   elements) may be used for storing any intermediate results. these may
   be left in the vector (undefined).
5. CRM applies when Rc=1.  When CRM is zero, the CR associated with
   the result is regarded as a "some results met standard CR result
   criteria". When CRM is one, this changes to "all results met standard
   CR criteria".
6. implementations MAY use destoffs as well as srcoffs (see [[sv/sprs]])
   in order to store sufficient state to resume operation should an
   interrupt occur. this is also why implementations are permitted to use
   the destination vector to store intermediary computations
7. *Predication may be applied*.  zeroing mode is not an option.  masked-out
   inputs are ignored; masked-out elements in the destination vector are
   unaltered (not used for the purposes of intermediary storage); the
   scalar result is placed in the first available unmasked element.

TODO: Rc=1 on Scalar Logical Operations? is this possible? was space
reserved in Logical Ops?

Pseudocode for the case where RA==RB:

    result = op(iregs[RA], iregs[RA+1])
    CR = analyse(result)
    for i in range(2, VL):
        result = op(result, iregs[RA+i])
        CRnew = analyse(result)
        if Rc=1
            if CRM:
                 CR = CR bitwise or CRnew
            else:
                 CR = CR bitwise AND CRnew

TODO: case where RA!=RB which involves first a vector of 2-operand
results followed by a mapreduce on the intermediates.

Note that when SVM is clear and SUBVL!=1 the sub-elements are *independent*, i.e. they
are mapreduced per *sub-element* as a result.  illustration with a vec2:

    result.x = op(iregs[RA].x, iregs[RA+1].x)
    result.y = op(iregs[RA].y, iregs[RA+1].y)
    for i in range(2, VL):
        result.x = op(result.x, iregs[RA+i].x)
        result.y = op(result.y, iregs[RA+i].y)

When SVM is set and SUBVL!=1, another variant is enabled.

    for i in range(VL):
        result = op(iregs[RA+i].x, iregs[RA+i].x)
        result = op(result, iregs[RA+i].z)
        result = op(result, iregs[RA+i].z)
        iregs[RT+i] = result

## Fail-on-first

Data-dependent fail-on-first has two distinct variants: one for LD/ST,
the other for arithmetic operations (actually, CR-driven).  Note in each
case the assumption is that vector elements are required appear to be
executed in sequential Program Order, element 0 being the first.

* LD/ST ffirst treats the first LD/ST in a vector (element 0) as an
  ordinary one.  Exceptions occur "as normal".  However for elements 1
  and above, if an exception would occur, then VL is **truncated** to the
  previous element.
* Data-driven (CR-driven) fail-on-first activates when Rc=1 or other
  CR-creating operation produces a result (including cmp).  Similar to
  branch, an analysis of the CR is performed and if the test fails, the
  vector operation terminates and discards all element operations at and
  above the current one, and VL is truncated to the *previous* element.
  Thus the new VL comprises a contiguous vector of results, all of which
  pass the testing criteria (equal to zero, less than zero).

The CR-based data-driven fail-on-first is new and not found in ARM SVE
or RVV. It is extremely useful for reducing instruction count, however
requires speculative execution involving modifications of VL to get high
performance implementations.

In CR-based data-driven fail-on-first there is only the option to select
and test one bit of each CR (just as with branch BO).  For more complex
tests this may be insufficient.  If that is the case, a vectorised crops
(crand, cror) may be used, and ffirst applied to the crop instead of to
the arithmetic vector.

One extremely important aspect of ffirst is:

* LDST ffirst may never set VL equal to zero.  This because on the first
  element an exception must be raised "as normal".
* CR-based data-dependent ffirst on the other hand **can** set VL equal
  to zero. This is the only means in the entirety of SV that VL may be set
  to zero (with the exception of via the SV.STATE SPR).  When VL is set
  zero due to the first element failing the CR bit-test, all subsequent
  vectorised operations are effectively `nops` which is
  *precisely the desired and intended behaviour*.

## pred-result mode

This mode merges common CR testing with predication, saving on instruction count. Below is the pseudocode excluding predicate zeroing and elwidth overrides.

    for i in range(VL):
        # predication test, skip all masked out elements.
        if predicate_masked_out(i):
             continue
        result = op(iregs[RA+i], iregs[RB+i])
        CRnew = analyse(result) # calculates eq/lt/gt
        # Rc=1 always stores the CR
        if Rc=1:
            crregs[offs+i] = CRnew
        # now test CR, similar to branch
        if CRnew[BO[0:1]] != BO[2]:
            continue # test failed: cancel store
        # result optionally stored but CR always is
        iregs[RT+i] = result

The reason for allowing the CR element to be stored is so that post-analysis
of the CR Vector may be carried out.  For example: Saturation may have occurred (and been prevented from updating, by the test) but it is desirable to know *which* elements fail saturation.

Note that predication is still respected: predicate zeroing is slightly different: elements that fail the CR test *or* are masked out are zero'd.

## CR Operations

CRs are slightly more involved than INT or FP registers due to the
possibility for indexing individual bits (crops BA/BB/BT).  Again however
the access pattern needs to be understandable in relation to v3.0B / v3.1B
numbering, with a clear linear relationship and mapping existing when
SV is applied.

### CR EXTRA mapping table and algorithm

Numbering relationships for CR fields are already complex due to being
in BE format (*the relationship is not clearly explained in the v3.0B
or v3.1B specification*).  However with some care and consideration
the exact same mapping used for INT and FP regfiles may be applied,
just to the upper bits, as explained below.

In OpenPOWER v3.0/1, BF/BT/BA/BB are all 5 bits.  The top 3 bits (2:4)
select one of the 8 CRs; the bottom 2 bits (0:1) select one of 4 bits
*in* that CR.  The numbering was determined (after 4 months of
analysis and research) to be as follows:

    CR_index = 7-(BA>>2)      # top 3 bits but BE
    bit_index = 3-(BA & 0b11) # low 2 bits but BE
    CR_reg = CR[CR_index]      # get the CR
    # finally get the bit from the CR.
    CR_bit = (CR_reg & (1<<bit_index)) != 0

When it comes to applying SV, it is the CR\_reg number to which SV EXTRA2/3
applies, **not** the CR\_bit portion (bits 0:1):

    if extra3_mode:
        spec = EXTRA3
    else:
        spec = EXTRA2<<1 | 0b0
    if spec[2]:
       # vector constructs "BA[2:4] spec[0:1] 0 BA[0:1]"
       return ((BA >> 2)<<5) | # hi 3 bits shifted up
              (spec[0:1]<<3) |  # to make room for these
              (BA & 0b11)      # CR_bit on the end
    else:
       # scalar constructs "0 spec[0:1] BA[0:4]"
       return (spec[0:1] << 5) | BA

Thus, for example, to access a given bit for a CR in SV mode, the v3.0B
algorithm to determin CR\_reg is modified to as follows:

    CR_index = 7-(BA>>2)      # top 3 bits but BE
    if spec[2]:
        # vector mode
        CR_index = (CR_index<<3) | (spec[0:1] << 1)
    else:
        # scalar mode
        CR_index = (spec[0:1]<<3) | CR_index
    # same as for v3.0/v3.1 from this point onwards
    bit_index = 3-(BA & 0b11) # low 2 bits but BE
    CR_reg = CR[CR_index]      # get the CR
    # finally get the bit from the CR.
    CR_bit = (CR_reg & (1<<bit_index)) != 0

Note here that the decoding pattern to determine CR\_bit does not change.

Note: high-performance implementations may read/write Vectors of CRs in
batches of aligned 32-bit chunks (CR0-7, CR7-15).  This is to greatly
simplify internal design.  If instructions are issued where CR Vectors
do not start on a 32-bit aligned boundary, performance may be affected.

### CR fields as inputs/outputs of vector operations

CRs (or, the arithmetic operations associated with them)
may be marked as Vectorised or Scalar.  When Rc=1 in arithmetic operations that have no explicit EXTRA to cover the CR, the CR is Vectorised if the destination is Vectorised.  Likewise if the destination is scalar then so is the CR.

When vectorized, the CR inputs/outputs are sequentially read/written
to 4-bit CR fields.  Vectorised Integer results, when Rc=1, will begin
writing to CR8 (TBD evaluate) and increase sequentially from there.
This is so that:

* implementations may rely on the Vector CRs being aligned to 8. This
  means that CRs may be read or written in aligned batches of 32 bits
  (8 CRs per batch), for high performance implementations.
* scalar Rc=1 operation (CR0, CR1) and callee-saved CRs (CR2-4) are not
  overwritten by vector Rc=1 operations except for very large VL
* CR-based predication, from CR32, is also not interfered with
  (except by large VL).

However when the SV result (destination) is marked as a scalar by the
EXTRA field the *standard* v3.0B behaviour applies: the accompanying
CR when Rc=1 is written to.  This is CR0 for integer operations and CR1
for FP operations.

Note that yes, the CRs are genuinely Vectorised.  Unlike in SIMD VSX which
has a single CR (CR6) for a given SIMD result, SV Vectorised OpenPOWER
v3.0B scalar operations produce a **tuple** of element results: the
result of the operation as one part of that element *and a corresponding
CR element*.  Greatly simplified pseudocode:

    for i in range(VL):
         # calculate the vector result of an add
         iregs[RT+i] = iregs[RA+i] + iregs[RB+i]
         # now calculate CR bits
         CRs[8+i].eq = iregs[RT+i] == 0
         CRs[8+i].gt = iregs[RT+i] > 0
         ... etc

If a "cumulated" CR based analysis of results is desired (a la VSX CR6)
then a followup instruction must be performed, setting "reduce" mode on
the Vector of CRs, using cr ops (crand, crnor)to do so.  This provides far
more flexibility in analysing vectors than standard Vector ISAs.  Normal
Vector ISAs are typically restricted to "were all results nonzero" and
"were some results nonzero". The application of mapreduce to Vectorised
cr operations allows far more sophisticated analysis, particularly in
conjunction with the new crweird operations see [[sv/cr_int_predication]].

Note in particular that the use of a separate instruction in this way
ensures that high performance multi-issue OoO inplementations do not
have the computation of the cumulative analysis CR as a bottleneck and
hindrance, regardless of the length of VL.

(see [[discussion]].  some alternative schemes are described there)

### Rc=1 when SUBVL!=1

sub-vectors are effectively a form of SIMD (length 2 to 4). Only 1 bit of predicate is allocated per subvector; likewise only one CR is allocated
per subvector.

This leaves a conundrum as to how to apply CR computation per subvector, when normally Rc=1 is exclusively applied to scalar elements.  A solution is to perform a bitwise OR or AND of the subvector tests.  Given that OE is ignored, rhis field may (when available) be used to select OR or AND behavior.

### Table of CR fields

CR[i] is the notation used by the OpenPower spec to refer to CR field #i,
so FP instructions with Rc=1 write to CR[1] aka SVCR1_000.

CRs are not stored in SPRs: they are registers in their own right.
Therefore context-switching the full set of CRs involves a Vectorised
mfcr or mtcr, using VL=64, elwidth=8 to do so.  This is exactly as how scalar OpenPOWER context-switches CRs: it is just that there are now more of them.

The 64 SV CRs are arranged similarly to the way the 128 integer registers
are arranged.  TODO a python program that auto-generates a CSV file
which can be included in a table, which is in a new page (so as not to
overwhelm this one). [[svp64/cr_names]]

## Register Profiles

**NOTE THIS TABLE SHOULD NO LONGER BE HAND EDITED** see
<https://bugs.libre-soc.org/show_bug.cgi?id=548> for details.

Instructions are broken down by Register Profiles as listed in the
following auto-generated page: [[opcode_regs_deduped]].  "Non-SV"
indicates that the operations with this Register Profile cannot be
Vectorised (mtspr, bc, dcbz, twi)

TODO generate table which will be here [[svp64/reg_profiles]]

## Assembly Annotation

Assembly code annotation is required for SV to be able to successfully
mark instructions as "prefixed".

A reasonable (prototype) starting point:

    svp64 [field=value]*

Fields:

* ew=8/16/32 - element width
* sew=8/16/32 - source element width
* vec=2/3/4 - SUBVL
* mode=reduce/satu/sats/crpred
* pred=1\<\<3/r3/~r3/r10/~r10/r30/~r30/lt/gt/le/ge/eq/ne
* spred={reg spec}

