# Links

* <http://lists.libre-soc.org/pipermail/libre-soc-dev/2020-December/001498.html>>

# Notes on requirements for bit allocations

do not try to jam VL or MAXVL in.  go with the flow of 24 bits spare.

* 2: SUBVL
* 2: elwidth
* 2: twin-predication (src, dest) elwidth
* 1: select INT or CR predication
* 3: predicate selection and inversion (QTY 2 for tpred)
* 4x2 or 3x3: src1/2/3/dest Vector/Scalar reg
* 2: saturate mode

totals: 24 bits (dest elwidth shared)

http://lists.libre-soc.org/pipermail/libre-soc-dev/2020-December/001434.html

## twin predication

twin predication and twin elwidth overrides is extremely important to have to be able to override both the src and dest elwidth yet keep the underlying scalar operation intact.  examples include mr with an elwidth=8, VL=8 on the src will take a byte at a time from one 64 bit reg and place it into 8x 64-bit regs, zero-extended.  more complex operations involve SUBVL and Audio/Video DSP operations, see [[av_opcodes]]

something like:

| 0   1 | 2 3 | 4 5 | 6    | 7  9 | 10 12 | 13 18 | 19 21 |
| ----- | --- | --- | ---- | ---- | ----- | ----- | ----- |
| subvl | sew | dew | ptyp | psrc | pdst  | vspec | sat   |

* subvl - 1 to 4 scalar / vec2 / vec3 / vec4
* sew / dew - DEFAULT / 8 / 16 /32 element width
* ptyp - predication INT / CR
* psrc / pdst - predicate mask selector and inversion
* vspec - 3 bit src / dest scalar-vector extension
* sat: 0bSU - S=1 signed U=1 unsigned 0b11 reserved

## twin predication, CR based.

separate src and dest predicates are a critical part of SV for provision of VGATHER, VSCATTER, VREDUCE, VSPLAT and many more operations.

Twin CR predication could be done in two ways:

* start from different CRs for the src and dest
* start from the same CR.

With different bits being selectable (CR[0..3]) starting from the same CR makes some sense.


# standard arith ops (single predication)

these are of the form res = op(src1, src2, ...)

| 0   1 | 2 3 | 4 5 | 6    | 7  9 | 10 18 | 19 21 |
| ----- | --- | --- | ---- | ---- | ----- | ----- |
| subvl | sew | dew | ptyp | pred | vspec | sat   |

* subvl - 1 to 4 scalar / vec2 / vec3 / vec4
* sew / dew - DEFAULT / 8 / 16 /32 element width
* ptyp - predication INT / CR
* pred - predicate mask selector and inversion
* vspec - 2/3 bit src / dest scalar-vector extension
* sat: 0bSU - S=1 signed U=1 unsigned 0b11 reserved

For 2 op (dest/src1/src2) the tag may be 3 bits: total 9 bits.  for 3 op (dest/src1/2/3) the vspec may be 2 bits per reg: total 8 bits.

Note:

* saturation is done on the result at the **source** elwidth
* signed-saturation causes sign-extension from source to dest elwidths **after** saturation

# Notes about rounding, clamp and saturate

One of the issues with vector ops is that in integer DSP ops for example in Audio the operation must clamp or saturate rather than overflow or ignore the upper bits and become a modulo operation.  This for Audio is extremely important, also to provide an indicator as to whether saturation occurred.  see  [[av_opcodes]].

If there are spare bits it would be very good to look at using some of them to specify the mode, because otherwise a SPR has to be used which will need to be set and unset.  This can get costly.

Idea: 2 bits for clamping mode? similar to elwidth:

* 0b00 default (no clamp)
* 0b01 8 bit (sel: -128/127, us:0/255)
* 0b10 16 bit
* 0b11 32 bit

not the same *as* elwidth.

# Notes about Swizzle

Basically, there isn't enough room to try to fit two src src1/2 swizzle, and SV, even into 64 bit (actually 24) without severely compromising on the number of bits allocated to either swizzle, or SV, or both.

therefore the strategy proposed is:

* design 16bit scalar ops
* use the 11 bit old SV prefix to create 32bit insns
* when those are embedded into v3.1B 64 prefix, the 24 bits are entirely allocated to swizzle.

with 2x12 this would mean no need to have complex encoding of swizzle.

if we really do need 2 bits spare then the complex encoder of swizzle could be deployed.

