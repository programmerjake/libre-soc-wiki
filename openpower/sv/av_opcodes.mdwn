# Scalar OpenPOWER Audio and Video Opcodes

the fundamental principle of SV is a hardware for-loop. therefore the first (and in nearly 100% of cases only) place to put Vector operations is first and foremost in the *scalar* ISA.  However only by analysing those scalar opcodes *in* a SV Vectorisation context does it become clear why they are needed and how they may be designed.

This page therefore has acompanying discussion at <https://bugs.libre-soc.org/show_bug.cgi?id=230> for evolution of suitable opcodes.

# Audio

The fundamental principle for these instructions is:

* identify the scalar primitive
* assume that longer runs of scalars will have Simple-V vectorisatin applied
* assume that "swizzle" may be applied at the (vec2 - SUBVL=2) Vector level,
  in order to perform the necessary HI/LO selection normally hard-coded
  into SIMD ISAs.

Thus for example, where OpenPOWER VSX has vpkswss, this would be achieved in SV with simply:

* addition of a scalar ext/clamp instruction
* 1st op, swizzle-selection vec2 "select X only" from source to dest:
  dest.X = extclamp(src.X)
* 2nd op, swizzle-select vec2 "select Y only" from source to dest
  dest.Y = extclamp(src.Y)

Macro-op fusion may be used to detect that these two interleave cleanly, overlapping the vec2.X with vec2.Y to produce a single vec2.XY operation.

## Scalar element operations

* clamping / saturation for signed and unsigned.  best done similar to FP rounding modes, i.e. with an SPR.
* average-add.  result = (src1 + src2 + 1) >> 1
* abs-diff: result = (src1 > src2) ? (src1-src2) : (src2-src1)
* signed min/max

# Video

TODO

* DCT <https://users.cs.cf.ac.uk/Dave.Marshall/Multimedia/node231.html>
* <https://www.nayuki.io/page/fast-discrete-cosine-transform-algorithms>

# VSX SIMD

Useful parts of VSX, and how they might map.

## vpks[\*][\*]s (vec_pack*)

signed and unsigned, these are N-to-M (N=64/32/16, M=32/16/8) chop/clamp/sign/zero-extend operations. May be implemented by a clamped move to a smaller elwidth.

The other direction, vec_unpack widening ops, may need some way to tell whether to sign-extend or zero-extend.

*scalar extsw/b/h gives one set, mv gives another.  src elwidth override and dest rlwidth override provide the pack/unpack*
 
## vavgs\* (vec_avg)

signed and unsigned, 8/16/32: these are all of the form:

    result = truncate((a + b + 1) >> 1))

*These do not exist in scalar ISA and would need to be added.  Essentially it is a type of post-processing involving the CA bit so could be included in the existing scalar pipeline ALU*

## vabsdu\* (vec_abs)

unsigned 8/16/32: these are all of the form:

    result = (src1 > src2) ? truncate(src1-src2) :
                             truncate(src2-src1)

*These do not exist in the scalar ISA and would need to be added*

## vmaxs\* / vmaxu\* (and min)

signed and unsigned, 8/16/32: these are all of the form:

    result = (src1 > src2) ? src1 : src2 # max
    result = (src1 < src2) ? src1 : src2 # min

*These do not exist in the scalar INTEGER ISA and would need to be added*

## vmerge operations

Their main point was to work around the odd/even multiplies. SV swizzles and mv.x should handle all cases.

these take two src vectors of various widths and splice them together.  the best technique to cover these is a simple straightforward predicated pair of mv operations, inverting the predicate in the second case, or, alternately, to use a pair of vec2 (SUBVL=2) swizzled operations.

in the swizzle case the first instruction would be destvect2.X = srcvec2.X and the second would swizzle-select Y.  macro-op fusion in both the prefixated variant and the swizzle variant would interleave the two into the same SIMD backend ALUs.

with twin predication the elwidth can be overridden on both src and dest such that either straight scalar mv or extsw/b/h can be used to provide the combinations of coverage needed, with only 2 actual instructions (plus vectir prefixing)

## Float estimates

    vec_expte - float 2^x
    vec_loge - float log2(x)
    vec_re - float 1/x
    vec_rsqrte - float 1/sqrt(x)

The spec says the max relative inaccuracy is 1/4096.

*These could be done by assigning meaning to the "sat mode" SVP64 bits in a FP context. 0b00 is IEEE754 FP, 0b01 is 2^12 accuracy for FP32. These can be applied to standard scalar FP ops"

## vec_madd(s) - FMA, multiply-add, optionally saturated

    a * b + c

*Standard scalar madd*

## vec_msum(s) - horizontal gather multiply-add, optionally saturated

This should be separated to a horizontal multiply and a horizontal add. How a horizontal operation would work in SV is TBD, how wide is it, etc.

    a.x + a.y + a.z ...
    a.x * a.y * a.z ...

*This would realistically need to be done with a loop doing a mapreduce sequrnce.  I looked very early on at doing this type of operation and concluded it would be better done with a series of halvings each time, as separate instructions:  VL=16 then VL=8 then 4 then 2 and finally one scalar.  An OoO multi-issue engine woukd be more than capable of desling with the Dependencies.*

## vec_mul*

There should be both a same-width multiply and a widening multiply. Signed and unsigned versions. Optionally saturated.

    u8 * u8 = u8
    u8 * u8 = u16

For 8,16,32,64, resulting in 8,16,32,64,128.

*All of these can be done with SV elwidth overrides, as long as the dest is no greater than 128.  SV specifically does not do 128 bit arithmetic.  Specifying src elwidth=8 and dest elwidth=16 will give a widening multiply*

## vec_rl - rotate left

    (a << x) | (a >> (WIDTH - x))

*Standard scalar rlwinm*

## vec_sel - bitwise select

    (a ? b : c)

## vec_splat - scatter

Implemented using swizzle/predicate.

## vec_perm - permute

Implemented using swizzle, mv.x.

## vec_*c[tl]z, vec_popcnt - count leading/trailing zeroes, set bits

Bit counts.

    ctz - count trailing zeroes
    clz - count leading zeroes
    popcnt - count set bits

*These all exist in the scalar ISA*
