# Scalar OpenPOWER Audio and Video Opcodes

the fundamental principle of SV is a hardware for-loop. therefore the first (and in nearly 100% of cases only) place to put Vector operations is first and foremost in the *scalar* ISA.  However only by analysing those scalar opcodes *in* a SV Vectorisation context does it become clear why they are needed and how they may be designed.

This page therefore has acompanying discussion at <https://bugs.libre-soc.org/show_bug.cgi?id=230> for evolution of suitable opcodes.

# Audio

The fundamental principle for these instructions is:

* identify the scalar primitive
* assume that longer runs of scalars will have Simple-V vectorisatin applied
* assume that "swizzle" may be applied at the (vec2 - SUBVL=2) Vector level,
  in order to perform the necessary HI/LO selection normally hard-coded
  into SIMD ISAs.

Thus for example, where OpenPOWER VSX has vpkswss, this would be achieved in SV with simply:

* addition of a scalar ext/clamp instruction
* 1st op, swizzle-selection vec2 "select X only" from source to dest:
  dest.X = extclamp(src.X)
* 2nd op, swizzle-select vec2 "select Y only" from source to dest
  dest.Y = extclamp(src.Y)

Macro-op fusion may be used to detect that these two interleave cleanly, overlapping the vec2.X with vec2.Y to produce a single vec2.XY operation.

## Scalar element operations

* clamping / saturation for signed and unsigned.  best done similar to FP rounding modes, i.e. with an SPR.
* average-add.  result = (src1 + src2 + 1) >> 1
* abs-diff: result = (src1 > src2) ? (src1-src2) : (src2-src1)
* signed min/max

# Video

TODO

* DCT <https://users.cs.cf.ac.uk/Dave.Marshall/Multimedia/node231.html>
* <https://www.nayuki.io/page/fast-discrete-cosine-transform-algorithms>

# VSX SIMD

Useful parts of VSX, and how they might map.

## vpks[\*][\*]s (vec_pack*)

signed and unsigned, these are N-to-M (N=64/32/16, M=32/16/8) chop/clamp/sign/zero-extend operations. May be implemented by a clamped move to a smaller elwidth.

The other direction, vec_unpack widening ops, may need some way to tell whether to sign-extend or zero-extend.
 
## vavgs\* (vec_avg)

signed and unsigned, 8/16/32: these are all of the form:

    result = truncate((a + b + 1) >> 1))

## vabsdu\* (vec_abs)

unsigned 8/16/32: these are all of the form:

    result = (src1 > src2) ? truncate(src1-src2) :
                             truncate(src2-src1)

## vmaxs\* / vmaxu\* (and min)

signed and unsigned, 8/16/32: these are all of the form:

    result = (src1 > src2) ? src1 : src2 # max
    result = (src1 < src2) ? src1 : src2 # min

## vmerge operations

Their main point was to work around the odd/even multiplies. SV swizzles and mv.x should handle all cases.

these take two src vectors of various widths and splice them together.  the best technique to cover these is a simple straightforward predicated pair of mv operations, inverting the predicate in the second case, or, alternately, to use a pair of vec2 (SUBVL=2) swizzled operations.

in the swizzle case the first instruction would be destvect2.X = srcvec2.X and the second would swizzle-select Y.  macro-op fusion in both the prefixated variant and the swizzle variant would interleave the two into the same SIMD backend ALUs.

with twin predication the elwidth can be overridden on both src and dest such that either straight scalar mv or extsw/b/h can be used to provide the combinations of coverage needed, with only 2 actual instructions (plus vectir prefixing)

## Float estimates

    vec_expte - float 2^x
    vec_loge - float log2(x)
    vec_re - float 1/x
    vec_rsqrte - float 1/sqrt(x)

The spec says the max relative inaccuracy is 1/4096.

## vec_madd(s) - FMA, multiply-add, optionally saturated

    a * b + c

## vec_msum(s) - horizontal gather multiply-add, optionally saturated

This should be separated to a horizontal multiply and a horizontal add. How a horizontal operation would work in SV is TBD, how wide is it, etc.

    a.x + a.y + a.z ...
    a.x * a.y * a.z ...

## vec_mul*

There should be both a same-width multiply and a widening multiply. Signed and unsigned versions. Optionally saturated.

    u8 * u8 = u8
    u8 * u8 = u16

For 8,16,32,64, resulting in 8,16,32,64,128.

## vec_rl - rotate left

    (a << x) | (a >> (WIDTH - x)

## vec_sel - bitwise select

    (a ? b : c)

## vec_splat - scatter

Implemented using swizzle/predicate.

## vec_perm - permute

Implemented using swizzle, mv.x.

## vec_*c[tl]z, vec_popcnt - count leading/trailing zeroes, set bits

Bit counts.

    ctz - count trailing zeroes
    clz - count leading zeroes
    popcnt - count set bits
