# SV Load and Store

Vectorisation of Load and Store requires creation, from scalar operations, a number of different types:

* fixed stride (contiguous sequence with no gaps)
* element strided (sequential but regularly offset, with gaps)
* vector indexed (vector of base addresses and vector of offsets)

OpenPOWER Load/Store operations may be seen from [[isa/fixedload]] and [[isa/fixedstore]] pseudocode to be of the form:

    lbux RT, RA, RB
    EA <- (RA) + (RB)
    RT <- MEM(EA)

and for immediate variants:

    lb RT,D(RA)
    EA <- RA + EXTS(D)
    RT <- MEM(EA)

Thus in the first example, the source registers may each be independently marked as scalar or vector, and likewise the destination; in the second example only the one source and one dest may be marked as scalar or vector.

Thus we can see that Vector Indexed may be covered, but there is not a convenient way to provide both fixed and element strided.  This is a known limitation of retro-fitting an existing scalar ISA with Vectorisation.  The solution requires an operation that has both RA, RB and an immediate.

At the minimum however it is possible to provide unit stride and vector mode, as follows:

    function op_ld(RT, RA, immed) # LD not VLD!
      rdv = map_dest_extra(RT);
      rsv = map_src_extra(RA);
      ps = get_pred_val(FALSE, RA); # predication on src
      pd = get_pred_val(FALSE, RT); # ... AND on dest
      for (int i = 0, int j = 0; i < VL && j < VL;):
        # skip nonpredicates elements
        if (RA.isvec) while (!(ps & 1<<i)) i++;
        if (RT.isvec) while (!(pd & 1<<j)) j++;
        if (RA.isvec)
          # indirect mode (multi mode)
          EA = ireg[rsv+i] + immed;
        else
          # unit stride mode
          EA = ireg[rsv] + i * immed
        ireg[rdv+j] <= MEM[EA];
        if (!RA.isvec && !RT.isvec)
            break # scalar-scalar
        if (RA.isvec) i++;
        if (RT.isvec) j++;

Indexed LD is:
 
    function op_ld(RT, RA, RB) # LD not VLD!
      rdv = map_dest_extra(RT);
      rsv = map_src_extra(RA);
      rso = map_src_extra(RB);
      ps = get_pred_val(FALSE, RA); # predication on src
      pd = get_pred_val(FALSE, RT); # ... AND on dest
      for (i=0, j=0, k=0; i < VL && j < VL && k < VL):
        # skip nonpredicates elements
        if (RA.isvec) while (!(ps & 1<<i)) i++; 
        if (RB.isvec) while (!(ps & 1<<k)) k++; 
        if (RT.isvec) while (!(pd & 1<<j)) j++; 
        EA = ireg[rsv] + ireg[rso] # indexed address
        ireg[rdv+j] <= MEM[EA];
        if (!RA.isvec && !RT.isvec && !RB.isvec)
            break # scalar-scalar
        if (RA.isvec) i++;
        if (RB.isvec) i++;
        if (RT.isvec) j++;

