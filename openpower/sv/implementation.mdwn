# Implementation

This page covers and coordinates implementing SV.  The basic concept is
to go step-by-step through the [[sv/overview]] adding each feature,
one at a time.

Links:

* <http://lists.libre-soc.org/pipermail/libre-soc-dev/2021-January/001865.html>
* <https://bugs.libre-soc.org/show_bug.cgi?id=578> python-based svp64
  assembler translator
* <https://bugs.libre-soc.org/show_bug.cgi?id=579> c/c++ macro svp64
  assembler translator
* <https://bugs.libre-soc.org/show_bug.cgi?id=577> gcc/binutils/svp64
* <https://bugs.libre-soc.org/show_bug.cgi?id=241> gem5 / ISACaller simulator
  - <https://bugs.libre-soc.org/show_bug.cgi?id=581> gem5 upstreaming
* <https://bugs.libre-soc.org/show_bug.cgi?id=583> TestIssuer


# Code to convert

There are four projects:

* TestIssuer (the HDL)
* ISACaller (the python-based simulator)
* power-gem5 (a cycle accurate simulator)
* Microwatt

Each of these needs to have SV augmentation, and the best way to
do it is if they are all done at the same time, implementing the same
incremental feature.

# Critical tasks

These are prerequisite tasks:

* power-gem5 automanagement, similar to pygdbmi for starting qemu
  - found this <https://www.gem5.org/documentation/general_docs/debugging_and_testing/debugging/debugging_simulated_code>
  just use pygdbmi
  - remote gdb should work <https://github.com/power-gem5/gem5/blob/gem5-experimental/src/arch/power/remote_gdb.cc>
* c++, c and python macros for generating [[sv/svp64]] assembler
  (svp64 prefixes)
  - python svp64 underway, minimalist sufficient for FU unit tests
<https://git.libre-soc.org/?p=soc.git;a=blob;f=src/soc/sv/trans/svp64.py;hb=HEAD>

People coordinating different tasks. This doesn't mean exclusive work on these areas it just means they are the "coordinator" and lead:

* Lauri:
* Jacob: C/C++ header for using SV through inline assembly
* Cesar: TestIssuer FSM
* Alain: power-gem5
* Cole:
* Luke: ISACaller, python-assembler-generator-class
* Tobias:
* Alexandre: binutils-svp64-assembler
* Paul: microwatt

# Adding SV

order: listed in [[sv/overview]]

## svp64 decoder

An autogenerator containing CSV files is available so that the task of creating deciders is not burdensome.  sv_analyse.py creates the CSV files, SVP64RM class picks them up.

* ISACaller: TODO
* power-gem5: TODO
* TestIssuer: TODO
* Microwatt: TODO
* python-based assembler-translator: 40% done (lkcl)
* c++ macros: underway (jacob)

## SVSTATE SPR needed

This is a peer of MSR but is stored in an SPR.  It should be considered part of the state of PC+MSR.

* ISACaller: TODO
* power-gem5: TODO
* TestIssuer: TODO
* Microwatt: TODO

## sv.setvl

a [[sv/setvl]] instruction is needed, which also implements [[sv/sprs]] i.e. primarily the `SVSTATE` SPR.  the dual-access SPRs for VL and MVL which mirror into the SVSTATE.VL and SVSTATE.MVL fields are not immediately essential to implement.

* ISACaller: TODO
* power-gem5: TODO
* TestIssuer: TODO
* Microwatt: TODO

## SVSRR0 for exceptions

SV's SVSTATE context is effectively a Sub-PC.  On exceptions the PC is saved into SRR0: it should come as no surprise that SVSTATE must be treated exactly the same.  SVSRR0 therefore is added to the list to be saved/restored in **exactly** the same way and time as SRR0 and SRR1.  This is fundamental and absolutely critical to view SVSTATE as a full peer of PC (CIA, NIA).

* ISACaller: TODO
* power-gem5: TODO
* TestIssuer: TODO
* Microwatt: TODO

## VL for-loop

main SV for-loop, as a FSM, updating `SVSTATE.srcstep`, using it as the index in the for-loop from 0 to VL-1

* ISACaller: TODO
* power-gem5: TODO
* TestIssuer: TODO
* Microwatt: TODO
