# move to/from vec2/3/4

See <https://bugs.libre-soc.org/show_bug.cgi?id=230#c30>

Basic idea: mv operations where either the src or dest is specifically marked as having SUBVL apply to it, but, crucially, the *other* argument does *not*.

     mv.srcvec  r3, r4.vec2
     mv.destvec r2.vec4, r5

TODO: evaluate whether this will fit with [[mv.swizzle]] involved as well
(yes it probably will)

* M=0 is mv.srcvec
* M=1 is mv.destvec

mv.srcvec (leaving out elwidths and chop):

    for i in range(VL):
        regs[rd+i] = regs[rs+i*SUBVL]

mv.destvec (leaving out elwidths and chop):

    for i in range(VL):
        regs[rd+i*SUBVL] = regs[rs+i]


# Twin Predication, saturation, swizzle, and elwidth overrides

Note that mv is a twin-predicated operation, and is swizzlable.  This implies that from the vec2, vec3 or vec4, 1 to 8 bytes may be selected and re-ordered (XYZW), mixed with 0 and 1 constants, skipped by way of twin predicate pack and unpack, and a huge amount besides.

Also saturation can be applied to individual elements, including the elements within a vec2/3/4.
