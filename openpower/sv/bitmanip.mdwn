# bit to byte permute

    do j = 0 to 7
      do k = 0 to 7
         b = VSR[VRB+32].dword[i].byte[k].bit[j]
         VSR[VRT+32].dword[i].byte[j].bit[k] = b

# vector bit deposit

vpdepd VRT,VRA,VRB

    do while(m < 64)
       if VSR[VRB+32].dword[i].bit[63-m]=1 then do
          result = VSR[VRA+32].dword[i].bit[63-k]
          VSR[VRT+32].dword[i].bit[63-m] = result
          k = k + 1
       m = m + 1

# vector bit extract

other way round

# single bit set

```
uint_xlen_t sbset(uint_xlen_t rs1, uint_xlen_t rs2) { int shamt = rs2 & (XLEN - 1);
}
return rs1 | (uint_xlen_t(1) << shamt);
uint_xlen_t sbclr(uint_xlen_t rs1, uint_xlen_t rs2) { int shamt = rs2 & (XLEN - 1);
}
return rs1 & ~(uint_xlen_t(1) << shamt);
uint_xlen_t sbinv(uint_xlen_t rs1, uint_xlen_t rs2) { int shamt = rs2 & (XLEN - 1);
}
return rs1 ^ (uint_xlen_t(1) << shamt);
uint_xlen_t sbext(uint_xlen_t rs1, uint_xlen_t rs2) { int shamt = rs2 & (XLEN - 1);
}
return 1 & (rs1 >> shamt);
```

# shuffle / unshuffle

```
uint64_t shuffle64_stage(uint64_t src, uint64_t maskL, uint64_t maskR, int N) { uint64_t x = src & ~(maskL | maskR);
}
x |= ((src << N) & maskL) | ((src >> N) & maskR); return x;
uint64_t shfl64(uint64_t rs1, uint64_t rs2) { uint64_t x = rs1;
}
int shamt = rs2 & 31;
if (shamt & 16) x = shuffle64_stage(x, 0x0000ffff00000000LL,
0x00000000ffff0000LL, 16); if (shamt & 8) x = shuffle64_stage(x, 0x00ff000000ff0000LL,
0x0000ff000000ff00LL, 8); if (shamt & 4) x = shuffle64_stage(x, 0x0f000f000f000f00LL,
0x00f000f000f000f0LL, 4); if (shamt & 2) x = shuffle64_stage(x, 0x3030303030303030LL,
0x0c0c0c0c0c0c0c0cLL, 2); if (shamt & 1) x = shuffle64_stage(x, 0x4444444444444444LL,
return x;
0x2222222222222222LL, 1);
uint64_t unshfl64(uint64_t rs1, uint64_t rs2) { uint64_t x = rs1;
}
int shamt = rs2 & 31;
if (shamt & 1) x = shuffle64_stage(x, 0x4444444444444444LL,
0x2222222222222222LL, 1); if (shamt & 2) x = shuffle64_stage(x, 0x3030303030303030LL,
0x0c0c0c0c0c0c0c0cLL, 2); if (shamt & 4) x = shuffle64_stage(x, 0x0f000f000f000f00LL,
0x00f000f000f000f0LL, 4); if (shamt & 8) x = shuffle64_stage(x, 0x00ff000000ff0000LL,
0x0000ff000000ff00LL, 8); if (shamt & 16) x = shuffle64_stage(x, 0x0000ffff00000000LL,
return x;
0x00000000ffff0000LL, 16);
```

# xperm

```
uint_xlen_t xperm(uint_xlen_t rs1, uint_xlen_t rs2, int sz_log2) { uint_xlen_t r = 0;
}
uint_xlen_t sz = 1LL << sz_log2; uint_xlen_t mask = (1LL << sz) - 1; for (int i = 0; i < XLEN; i += sz) { uint_xlen_t pos = ((rs2 >> i) & mask) << sz_log2; if (pos < XLEN)
r |= ((rs1 >> pos) & mask) << i; }return r;
uint_xlen_t xperm_n (uint_xlen_t rs1, uint_xlen_t rs2) { return xperm(rs1, rs2, 2); } uint_xlen_t xperm_b (uint_xlen_t rs1, uint_xlen_t rs2) { return xperm(rs1, rs2, 3); } uint_xlen_t xperm_h (uint_xlen_t rs1, uint_xlen_t rs2) { return xperm(rs1, rs2, 4); } uint_xlen_t xperm_w (uint_xlen_t rs1, uint_xlen_t rs2) { return xperm(rs1, rs2, 5); }
```
