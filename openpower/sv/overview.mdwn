# SV Overview

This document provides a crash-course overview as to why SV exists, and how it works.

[SIMD is known to be harmful](https://www.sigarch.org/simd-instructions-considered-harmful/):
a seductive simplicity that is easy to implement in hardware.  Even with predication added, SIMD only become more and more problematic with each power of two SIMD width increase introduced through an ISA revision.

Cray-style variable-length Vectors on the other hand result in stunningly elegant and small loops, with no alarmingly high setup and cleanup code, where at the hardware level the microarchitecture may execute from one element right the way through to tens of thousands at a time, yet the executable remains exactly the same.  Unlike in SIMD, powers of two limitations are not involved in either the hardware nor in the assembly code.

SimpleV takes the Cray style Vector principle and applies it to a Scalar ISA, in the process allowing register file size increases using "tagging" (similar to how x86 originally extended registers from 32 to 64 bit).

The fundamentals are:

* The Program Counter gains a "Sub Counter" context.
* Vectorisation pauses the PC and runs a loop from 0 to VL-1
 (where VL is Vector Length)
* During the loop the instruction at the PC is executed *multiple* 
  times.
* Some registers may be "tagged" as Vectors
* During the loop, "Vector"-tagged register are incrememted by
  one with each iteration.
* Once the loop is completed *only then* is the Program Counter
  allowed to move to the next instruction.

In OpenPOWER ISA v3.0B pseudo-code form, an ADD operation, assuming both source and destination have been "tagged" as Vectors, is simply:

    for i = 0 to VL-1:
         GPR(RT+i) = GPR(RA+i) + GPR(RB+i)

At its heart, SimpleV really is this simple.  On top of this fundamental basis further subtle refinements can be added which build up towards an extremely powerful Vector augmentation system, with very little in the way of additional opcodes required.

RISC-V RVV as of version 0.9 is over 180 instructions (more than the rest of RV64G combined). Over 95% of that functionality is added to OpenPOWER v3 0B, by SimpleV augmentation, with around 5 to 8 instructions.

Even in OpenPOWER v3.0B, the Scalar Integer ISA is around 150 instructions, with IEEE754 FP adding approximately 80 more. VSX, being based on SIMD design principles, adds somewhere in the region of 600 more.  SimpleV again provides over 95% of VSX functionality, simply by augmenting the *Scalar* OpenPOWER ISA, and in the process providing features such as predication, which VSX is entirely missing.

The rest of this document builds on the above simple loop to add:

* Vector-Scalar, Scalar-Vector and Scalar-Scalar operation
* Traditional Vector operations (VSPLAT, VINSERT, VCOMPRESS etc)
* Predication masks (essential for parallel if/else constructs)
* 8, 16 and 32 bit integer operations, and both FP16 and BF16.
* Fail-on-first (introduced in ARM SVE2)
* A new concept known as "Twin Predication"

All of this is *without modifying the OpenPOWER v3.0B ISA*, except to add "wrapping context", similar to how v3.1B 64 Prefixes work.

In fairness to both VSX and RVV, there are things that are not provided by SimpleV:

* 128 bit or above arithmetic and other operations
  (VSX Rijndael and SHA primitives; VSX shuffle operations)
* register files above 128
* Vector lengths over 64
* Unit-strided LD/ST and other comprehensive memory operations
  (struct-based LD/ST from RVV for example)
* 32-bit instruction lengths. [[svp64]] had to be added as 64 bit.

These are not insurmountable limitations, that, over time, may well be added in future revisions of SV. 

# Adding Scalar / Vector

The first augmentation to the simple loop is to add the option for all source and destinations to all be either scalar or vector.  As a FSM this is where our "simple" loop gets its first complexity.  

    function op_add(rd, rs1, rs2) # add not VADD!
      int id=0, irs1=0, irs2=0;
      for i = 0 to VL-1:
        ireg[rd+id] <= ireg[rs1+irs1] + ireg[rs2+irs2];
        if (!rd.isvec) break;
        if (rd.isvec)  { id += 1; }
        if (rs1.isvec)  { irs1 += 1; }
        if (rs2.isvec)  { irs2 += 1; }
        if (id == VL or irs1 == VL or irs2 == VL)
          break

With some walkthroughs it is clear that the loop exits immediately after the first scalar destination result is written, and that when the destination is a Vector the loop proceeds to fill up the register file, sequentially, starting at `rd` and ending at `rd+VL-1`. The two source registers will, independently, either remain pointing at `rs1` or `rs2` respectively, or, if marked as Vectors, will march incrementally in lockstep as the destination also progresses through elements.

In this way all the eight permutations of Scalar and Vector behaviour are covered, although without predication the scalar-destination ones are reduced in usefulness.  It does however clearly illustrate the principle.

Note in particular: there is no separate Scalar add instruction and separate Vector instruction and separate Scalar-Vector instruction: it's all the same instruction, just with a loop.  Scalar happens to set that loop size to one.

# Adding single predication

The next step is to add a single predicate mask.  This is where it gets interesting.  Predicate masks are a bitvector, each bit specifying, in order, whether the element operation is to be skipped ("masked out") or allowed If there is no predicate, it is set to all 1s

    function op_add(rd, rs1, rs2) # add not VADD!
      int id=0, irs1=0, irs2=0;
      predval = get_pred_val(FALSE, rd);
      for i = 0 to VL-1:
        if (predval & 1<<i) # predication bit test
           ireg[rd+id] <= ireg[rs1+irs1] + ireg[rs2+irs2];
           if (!rd.isvec) break;
        if (rd.isvec)  { id += 1; }
        if (rs1.isvec)  { irs1 += 1; }
        if (rs2.isvec)  { irs2 += 1; }
        if (id == VL or irs1 == VL or irs2 == VL)
           break

The key modification is to skip the creation and storage of the result if the relevant predicate mask bit is clear, but *not the progression through the registers*.

A particularly interesting case is if the destination is scalar, and the first few bits of the predicate are zero.  The loop proceeds to increment the Svalar *source* registers until the first nonzero predicate bit is found, whereupon a single result is computed, and *then* the loop exits.  This therefore uses the predicate to perform Vector source indexing.  This case was not possible without the predicate mask.

If all three registers are marked as Vector then the "traditional" predicated Vector behaviour is provided.  Yet, just as before, all other options are still provided, right the way back to the pure-scalar case, as if this were a straight OpenPOWER v3.0B non-augmented instruction.

