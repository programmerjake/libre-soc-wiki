# SV Overview

This document provides a crash-course overview as to why SV exists, and how it works.

[SIMD is known to be harmful](https://www.sigarch.org/simd-instructions-considered-harmful/):
a seductive simplicity that is easy to implement in hardware.  Without predication, which is common only in 3D GPUs, realistically,  at the time of writing (AVX512 came from Larrabee), SIMD widths only become more and more problematic.

Cray-style variable-length Vectors on the other hand result in stunningly elegant and small loops, with no alarmingly high setup and cleanup code, where at the hardware level the microarchitecture may execute from one element right the way through to tens of thousands at a time, yet the executable remains exactly the same.  Unlike in SIMD, powers of two limitations are not involved in either the hardware nor in the assembly code.

SimpleV takes the Cray style Vector principle and applies it to a scaalar architecture, in the process allowing register file size increases using "tagging" (similar to how x86 originally extended registers from 32 to 64 bit).

The fundamentals are:

* The Program Counter gains a "Sub Counter" context.
* Vectorisation pauses the PC and runs a loop from 0 to VL-1
 (where VL is Vector Length)
* During the loop the instruction at the PC is executed *multiple* 
  times.
* Some registers may be "tagged" as Vectors
* During the loop, "Vector"-tagged register are incrememted by
  one with each iteration.
* Once the loop is completed *only then* is the Program Counter
  allowed to move to the next instruction.

In OpenPOWER ISA v3.0B pseudo-code form, an ADD operation, assuming both source and destination have been "tagged" as Vectors, is simply:

    for i = 0 to VL-1:
         GPR(RT+i) = GPR(RA+i) + GPR(RB+i)

At its heart, SimpleV really is this simple.  On top of this fundamental basis further subtle refinements can be added which build up towards an extremely powerful Vector augmentation system, with very little in the way of additional opcodes required.

RISC-V RVV as of version 0.9 is over 180 instructions (more than the rest of RV64G combined). Over 95% of that functionality is added to OpenPOWER v3 0B, by SimpleV augmentation, with around 5 to 8 instructions.

Even in OpenPOWER v3.0B, the Scalar Integer ISA is around 150 instructions, with IEEE754 FP adding approximately 80 more. VSX, being based on SIMD design principles, adds somewhere in the region of 600 more.  SimpleV again provides over 95% of VSX functionality, simply by augmenting the *Scalar* OpenPOWER ISA, and in the process providing features such as predication, which VSX is entirely missing.

The rest of this document builds on the above simple loop to add:

* Vector-Scalar, Scalar-Vector and Scalar-Scalar operation
* Traditional Vector operations (VSPLAT, VINSERT, VCOMPRESS etc)
* Predication masks (essential for parallel if/else constructs)
* 8, 16 and 32 bit integer operations, and both FP16 and BF16.
* Fail-on-first (introduced in ARM SVE2)
* A new concept known as "Twin Predication"

All of this is *without modifying the OpenPOWER v3.0B ISA*, except to add "wrapping context", similar to how v3.1B 64 Prefixes work.

In fairness to both VSX and RVV, there are things that are not provided by SimpleV:

* 128 bit or above arithmetic and other operations
  (VSX Rijndael and SHA primitives; VSX shuffle operations)
* register files above 128
* Vector lengths over 64
* Unit-strided LD/ST and other comprehensive memory operations
  (struct-based LD/ST from RVV for example)
* 32-bit instruction lengths. [[svp64]] had to be added as 64 bit.

These are not insurmountable limitations, that, over time, may well be added in future revisions of SV. 







