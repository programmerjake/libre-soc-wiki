[[!tag standards]]

# SPRs <a name="sprs"></a>

There are five SPRs, available in any privilege level:

* MVL (the Maximum Vector Length)
* VL (which has different characteristics from standard SPRs)
* SUBVL (effectively a kind of SIMD)
* STATE (containing copies of MVL, VL and SUBVL as well as context information)
* SVSRR0 which is used for exceptions and traps to store SVSTATE.

MVL, VL and SUBVL are only provided for convenience: normally [[sv/setvl]] would be used to obtain a copy of VL, for example.

For Privilege Levels (trap handling) there are the following SPRs,
where x may be u, s or h for User, Supervisor or Hypervisor
Modes respectively:

* (x)eSTATE (useful for saving and restoring during context switch,
  and for providing fast transitions)

The u/s SPRs are treated and handled exactly like their (x)epc
equivalents.  On entry to or exit from a privilege level, the contents
of its (x)eSTATE are swapped with STATE.

# MAXVECTORLENGTH (MVL) <a name="mvl" />

MAXVECTORLENGTH is the same concept as MVL in RVV, except that it
is variable length and may be dynamically set.  MVL is
however limited to the regfile bitwidth, 64.

# Vector Length (VL) <a name="vl" />

VSETVL is slightly different from RVV.  Similar to RVV, VL is set to be within
the range 0 <= VL <= MVL (where MVL in turn is limited to 1 <= MVL <= XLEN)

    VL = rd = MIN(vlen, MVL)

where 1 <= MVL <= XLEN

# SUBVL - Sub Vector Length

This is a "group by quantity" that effectively asks each iteration
of the hardware loop to load SUBVL elements of width elwidth at a
time. Effectively, SUBVL is like a SIMD multiplier: instead of just 1
operation issued, SUBVL operations are issued.

The main effect of SUBVL is that predication bits are applied per
**group**, rather than by individual element.  Legal values are 1 to 4.
Illegal values raise an exception.

# STATE

This is a standard SPR that contains sufficient information for a
full context save/restore (see SVSRR0).  It contains (and permits setting of):

* MVL
* VL
* dststep - the destination element offset of the current parallel
  instruction being executed
* srcstep - for twin-predication, the source element offset as well.
* SUBVL
* svstep - the subvector element offset of the current
  parallel instruction being executed

The format of the STATE SPR is as follows:

| Field | Name     | Description           |
| ----- | -------- | --------------------- |
| 0:6   | maxvl    | Max Vector Length     |
| 7:13  |    vl    | Vector Length         |
| 14:20 | srcstep  | for srcstep = 0..VL-1 |
| 21:27 | dststep  | for dststep = 0..VL-1 |
| 28:29 | subvl    | Sub-vector length     |
| 30:31 | svstep   | for svstep = 0..SUBVL-1  |

The relationship between SUBVL and the subvl field is:

| SUBVL | (25..24) |
| ----- | -------- |
| 1     | 0b00     |
| 2     | 0b01     |
| 3     | 0b10     |
| 4     | 0b11     |

Notes:

* The entries are truncated to be within range.  Attempts to set VL to
  greater than MAXVL will truncate VL.
* Setting srcstep, dststep to 64 or greater, or VL or MVL to greater
  than 64 is reserved and will cause an illegal instruction trap.

# SVSRR0

In scalar v3.0B traps, exceptions and interrupts, two SRRs are saved/restored:

* SRR0 to store the PC (CIA/NIA)
* SRR1 to store a copy of the MSR

Given that SVSTATE is effectively a Sub-PC it is critically important to add saving/restoring of SVSTATE as a full peer equal in status to PC, in every way.  At any time PC is saved or restored, so is SVSTATE in **exactly** the same way for **exactly** the same reasons.

The SPR name given for the purposes of saving/restoring SVSTATE is SVSRR0.




