# a "yield" version of the REMAP algorithm. a little easier to read
# than the Finite State Machine version

# python "yield" can be iterated. use this to make it clear how
# the indices are generated by using natural-looking nested loops
def iterate_indices(SVSHAPE):
    # get indices to iterate over, in the required order
    xd = SVSHAPE.lims[SVSHAPE.order[2]]
    yd = SVSHAPE.lims[SVSHAPE.order[1]]
    zd = SVSHAPE.lims[SVSHAPE.order[0]]
    # create lists of indices to iterate over in each dimension
    x_r = list(range(xd))
    y_r = list(range(yd))
    z_r = list(range(zd))
    # invert the indices if needed
    if SVSHAPE.invxyz[SVSHAPE.order[2]]: x_r.reverse()
    if SVSHAPE.invxyz[SVSHAPE.order[1]]: y_r.reverse()
    if SVSHAPE.invxyz[SVSHAPE.order[0]]: z_r.reverse()
    # start an infinite (wrapping) loop
    skip = 0
    while True:
        for x in x_r:           # loop over 3rd order dimension
            for y in y_r:       # loop over 2nd order dimension
                for z in z_r:   # loop over 1st order dimension
                    # skip the first entries up to offset
                    if skip < SVSHAPE.offset:
                        skip += 1
                        continue
                    # construct the (up to) 3D remap schedule
                    yield (x + y * xd + z * xd * yd)

def demo():
    # set the dimension sizes here
    xdim = 3
    ydim = 2
    zdim = 1

    # set total (can repeat, e.g. VL=x*y*z*4)
    VL = xdim * ydim * zdim

    # set up an SVSHAPE
    class SVSHAPE:
        pass
    SVSHAPE0 = SVSHAPE()
    SVSHAPE0.lims = [xdim, ydim, zdim]
    SVSHAPE0.idxs = [0,0,0]   # starting indices
    SVSHAPE0.order = [1,0,2]  # experiment with different permutations, here
    SVSHAPE0.offset = 0       # experiment with different offset, here
    SVSHAPE0.invxyz = [0,1,0] # inversion if desired

    # enumerate over the iterator function, getting new indices
    for idx, new_idx in enumerate(iterate_indices(SVSHAPE0)):
        if idx >= VL:
            break
        print ("%d->%d" % (idx, new_idx))

# run the demo
if __name__ == '__main__':
    demo()
