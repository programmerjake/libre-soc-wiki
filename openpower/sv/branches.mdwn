# SVP64 Branch Conditional behaviour

Links

* <https://bugs.libre-soc.org/show_bug.cgi?id=664>
* <http://lists.libre-soc.org/pipermail/libre-soc-dev/2021-August/003416.html>
* [[openpower/isa/branch]]

Branch Conditional operations, `bc`, `bctar` etc. test a Condition Register.
When doing so, it is quite reasonable and logical to test a *Vector* of
CR Fields. In 3D Shader binaries, which are inherently parallelised
and predicated, testing all or some results and branching based on
multiple tests is extremely common.
Therefore, `sv.bc` and other Branch Conditional instructions are worth
including.

The `BI` field of Branch Conditional operations is five bits,
in scalar v3.0B this would select one bit of the 32 bit CR.
In SVP64 there are 16 32 bit CRs, containing 128 4-bit CR Fields.
Therefore, the 2 LSBs of `BI` select the bit from the CR, and the
top 3 bits are extended to either scalar or vector and to
select CR Fields 0..127 as specified
in SVP64 [[sv/svp64/appendix]]

When considering an "array" of branches, there are two useful modes:

* Branch takes place on the first CR test to succeed.
* Branch takes place only if **all** CR tests succeed
  (including those where the predicate is masked out
   and the corresponding CR Field is considered to be
   set to `SNZ`)

In Vertical-First Mode, the `ALL` bit should
not be used.  If set, behaviour is `UNDEFINED`.
(*The reason is that Vertical-First hints may permit
multiple elements up to hint length to be executed
in parallel, however the number is entirely up to
implementors.  Attempting to test an arbitrary
indeterminate number of Conditional tests is impossible
to define, and efforts to enforce such defined behaviour
interfere with Vertical-First mode parallel behaviour.*)

`svstep` mode is only meaningful in Vertical-First Mode.
The CR Field selected by `BI` is updated based on
incrementing srcstep and dststep, and performing the
same tests as [[sv/svstep]], following which the Branch
Conditional instruction proceeds as normal (reading
and testing the CR bit just updated, if the relevant
`BO` bit is set).  Note that the SVSTATE fields
are still updated, and the CR field still updated,
even if the `BO` bits do not require CR testing.

Predication in both INT and CR modes may be applied to
`sv.bc` and other SVP64 Branch Conditional operations,
exactly as they may be applied to other SVP64 operations.
When `sz` is zero, any masked-out Branch-element operations
are masked-out (not executed), exactly like all other SVP64
operations.

However when `sz` is non-zero, this normally requests insertion
of a zero in place of the input data, when the relevant predicate
mask bit is zero.  This would mean that a zero is inserted in
place of `CR[BI+32]` for testing against `BO`, which may not
be desirable in all circumstances.  Therefore, an extra field
is provided `SNZ`, which, if set, will insert a **one** in
place of a masked-out element instead of a zero.

(*Note: Both options are provided because it is useful to
deliberately cause the Branch-Conditional Vector testing
to fail at a specific point, controlled by the Predicate
mask. This is particularly useful in `VLSET` mode, which
will truncate SVSTATE.VL at the point of the first failed
test.*)

SVP64 RM `MODE` for Branch Conditional:

| 0-1 |  2  |  3   4  |  description              |
| --- | --- |---------|-------------------------- |
| 00  | SNZ |  ALL sz | normal mode                      |
| 01  | VLI |  ALL sz | VLSET mode                      |
| 10  | SNZ |  ALL sz | svstep mode                      |
| 11  | VLI |  ALL sz | svstep VLSET mode                      |

Fields:

* **sz**  if predication is enabled will put 4 copies of `SNZ` in place of the src CR Field when the predicate bit is zero.  otherwise the element is ignored or skipped, depending on context.
* **ALL** when set, all branch conditional tests must pass in order for
the branch to succeed.
* **VLI** In VLSET mode, VL is set equal (truncated) to the first branch
which succeeds.  If VLI (Vector Length Inclusive) is clear, VL is truncated
to *exclude* the current element, otherwise it is included. SVSTATE.MVL is not changed.

svstep mode will run an increment of SVSTATE srcstep and dststep
(only meaningful in Vertical First Mode).  Unlike `svstep.` however
which updates only CR0 with the testing of REMAP loop progress,
the CR Field is taken from the branch `BI` field, and updated
prior to proceeding to branch conditional testing.

Note that, interestingly, due to the useful side-effects of `VLSET` mode
and `svstep` mode it is actually useful to use Branch Conditional even
to perform no actual branch operation, i.e to point to the instruction
after the branch.

Available options to combine:

* `BO` to select whether the CR bit being tested is zero or nonzero
* `R30` and `~R30` and other predicate mask options including CR and
  inverted CR bit testing
* `sz` and `SNZ` to insert either zeros or ones in place of masked-out
  predicate bits
* `ALL` or `ANY` behaviour corresponding to `AND` of all tests and
  `OR` of all tests, respectively.

Pseudocode for Horizontal-First Mode:

```
   if BO[0]:
       cond_ok = 1
   else
       cond_ok = not SVRMmode.ALL
       for i in range(VL):
           # select predicate bit or zero/one
           if predicate[i]:
               testbit = CR[BI+32+srcstep*4]
           else if not SVRMmode.sz:
               continue
           else
               testbit = SVRMmode.SNZ
           # actual element test herr
           el_cond_ok <- Â¬(testbit ^ BO[1])
           # merge in the test
           if SVRMmode.ALL:
               cond_ok &= el_cond_ok
           else
               cond_ok |= el_cond_ok
           # test for VL to be set (and exit)
           if ~el_cond_ok and VLSET
               if SVRMmode.VLI
                   SVSTATE.VL = i+1
               else
                   SVSTATE.VL = i
               break
           # early exit? 
           if SVRMmode.ALL:
               if ~el_cond_ok:
                   break
           else
               if el_cond_ok:
                   break
```
