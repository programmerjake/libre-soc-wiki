# SVP64 Branch Conditional behaviour

Links

* <https://bugs.libre-soc.org/show_bug.cgi?id=664>
* <http://lists.libre-soc.org/pipermail/libre-soc-dev/2021-August/003416.html>
* [[openpower/isa/branch]]

Scalar 3.0B Branch Conditional operations, `bc`, `bctar` etc. test a Condition Register.
When doing so in a Vector Context, it is quite reasonable and logical to test a *Vector* of
CR Fields. In 3D Shader binaries, which are inherently parallelised
and predicated, testing all or some results and branching based on
multiple tests is extremely common, and a fundamental part of
Shader Compilers.
Therefore, `sv.bc` and other Vector-aware Branch Conditional instructions are worth
including.

The `BI` field of Branch Conditional operations is five bits,
in scalar v3.0B this would select one bit of the 32 bit CR.
In SVP64 there are 16 32 bit CRs, containing 128 4-bit CR Fields.
Therefore, the 2 LSBs of `BI` select the bit from the CR Field, and the
top 3 bits are extended to either scalar or vector and to
select CR Fields 0..127 as specified
in SVP64 [[sv/svp64/appendix]]

When considering an "array" of branches, there are two useful modes:

* Branch takes place on the first CR test to succeed
  (a Great Big OR of all condition tests)
* Branch takes place only if **all** CR tests succeed:
  a Great Big AND of all condition tests
  (including those where the predicate is masked out
   and the corresponding CR Field is considered to be
   set to `SNZ`)

In SVP64 Horizontal-First Mode, the first failure
in ALL mode (Great Big AND) results in early exit: no more updates to
CTR occur (if requested); no branch occurs. Likewise
for non-ALL mode (Great Big Or) on first success early
exit also occurs, however this time with the Branch proceeding.
In both cases the testing of the Vector of CRs should be
done in linear sequential order (or in REMAP re-sequenced order):
such that tests beyond the exit point are *not* carried out.

In Vertical-First Mode, the `ALL` bit should
not be used.  If set, behaviour is `UNDEFINED`.
(*The reason is that Vertical-First hints may permit
multiple elements up to hint length to be executed
in parallel, however the number is entirely up to
implementors.  Attempting to test an arbitrary
indeterminate number of Conditional tests is impossible
to define, and efforts to enforce such defined behaviour
interfere with Vertical-First mode parallel 
opportunistic behaviour.*)

In `svstep` mode,
the whole CR Field, part of which is
selected by `BI` (top 3 bits) is updated based on
incrementing srcstep and dststep, and performing the
same tests as [[sv/svstep]], following which the Branch
Conditional instruction proceeds as normal (reading
and testing the CR bit just updated, if the relevant
`BO` bit is set).  Note that the SVSTATE fields
are still updated, and the CR field still updated,
even if the `BO` bits do not require CR testing.

Predication in both INT and CR modes may be applied to
`sv.bc` and other SVP64 Branch Conditional operations,
exactly as they may be applied to other SVP64 operations.
When `sz` is zero, any masked-out Branch-element operations
are not executed, exactly like all other SVP64
operations.

However when `sz` is non-zero, this normally requests insertion
of a zero in place of the input data, when the relevant predicate
mask bit is zero.  This would mean that a zero is inserted in
place of `CR[BI+32]` for testing against `BO`, which may not
be desirable in all circumstances.  Therefore, an extra field
is provided `SNZ`, which, if set, will insert a **one** in
place of a masked-out element instead of a zero.

(*Note: Both options are provided because it is useful to
deliberately cause the Branch-Conditional Vector testing
to fail at a specific point, controlled by the Predicate
mask. This is particularly useful in `VLSET` mode, which
will truncate SVSTATE.VL at the point of the first failed
test.*)

SVP64 RM `MODE` for Branch Conditional:

| 0-1 |  2  |  3   4  |  description              |
| --- | --- |---------|-------------------------- |
| 00  | SNZ |  ALL sz | normal mode                      |
| 01  | VLI |  ALL sz | VLSET mode                      |
| 10  | SNZ |  ALL sz | svstep mode                      |
| 11  | VLI |  ALL sz | svstep VLSET mode, in Horizontal-First        |
| 11  | VLI |  SNZ sz | svstep VLSET mode, in Vertical-First    |

Fields:

* **sz**  if predication is enabled will put 4 copies of `SNZ` in place of the src CR Field when the predicate bit is zero.  otherwise the element is ignored or skipped, depending on context.
* **ALL** when set, all branch conditional tests must pass in order for
the branch to succeed.
* **VLI** In VLSET mode, VL is set equal (truncated) to the first branch
which succeeds.  If VLI (Vector Length Inclusive) is clear, VL is truncated
to *exclude* the current element, otherwise it is included. SVSTATE.MVL is not changed.

svstep mode will run an increment of SVSTATE srcstep and dststep
(which is still useful in Horizontal First Mode).  Unlike `svstep.` however
which updates only CR0 with the testing of REMAP loop progress,
the CR Field is taken from the branch `BI` field, and updated
prior to proceeding to each element branch conditional testing.

Note that, interestingly, due to the useful side-effects of `VLSET` mode
and `svstep` mode it is actually useful to use Branch Conditional even
to perform no actual branch operation, i.e to point to the instruction
after the branch.

In particular, svstep mode is still useful for Horizontal-First Mode
particularly in combination with REMAP. All "loop end" conditions
will be tested on a per-element basis and placed into a Vector of
CRs starting from the point specified by the Branch `BI` field.
This Vector of CR Fields may then be subsequently used as a Predicate
Mask, and, furthermore, if VLSET mode was requested, VL will have
been set to the length of one of the loop endpoints, again as specified
by the bit from the Branch `BI` field.

Also, the unconditional bit `BO[0]` is still relevant when Predication
is applied to the Branch because in `ALL` mode all nonmasked bits have
to be tested. Even when svstep mode or VLSET mode are not used, CTR
may still be decremented by the total number of nonmasked elements.
In short, Vectorised Branch becomes an extremely powerful tool.

Available options to combine:

* `BO[0]` to make an unconditional branch would seem irrelevant if
  it were not for predication and for side-effects.
* `BO[1]` to select whether the CR bit being tested is zero or nonzero
* `R30` and `~R30` and other predicate mask options including CR and
  inverted CR bit testing
* `sz` and `SNZ` to insert either zeros or ones in place of masked-out
  predicate bits
* `ALL` or `ANY` behaviour corresponding to `AND` of all tests and
  `OR` of all tests, respectively.

Pseudocode for Horizontal-First Mode:

```
   
    cond_ok = not SVRMmode.ALL
    for srcstep in range(VL):
        new_srcstep, CRbits = SVSTATE_NEXT(srcstep)
        # select predicate bit or zero/one
        if predicate[srcstep]:
            # get SVP64 extended CR field 0..127
            SVCRf = SVP64EXTRA(BI>>2)
            CR{SVCRf+srcstep} = CRbits
            testbit = CRbits[BI & 0b11]
            # testbit = CR[BI+32+srcstep*4]
        else if not SVRMmode.sz:
            continue
        else
            testbit = SVRMmode.SNZ
        # actual element test here
        el_cond_ok <- BO[0] | ¬(testbit ^ BO[1])
        # merge in the test
        if SVRMmode.ALL:
            cond_ok &= el_cond_ok
        else
            cond_ok |= el_cond_ok
        # test for VL to be set (and exit)
        if ~el_cond_ok and VLSET
            if SVRMmode.VLI
                SVSTATE.VL = srcstep+1
            else
                SVSTATE.VL = srcstep
            break
        # early exit? 
        if SVRMmode.ALL:
            if ~el_cond_ok:
                break
        else
            if el_cond_ok:
                break
```

Pseudocode for Vertical-First Mode:

```
    new_srcstep, CRbits = SVSTATE_NEXT(srcstep)
    # select predicate bit or zero/one
    if predicate[srcstep]:
        # get SVP64 extended CR field 0..127
        SVCRf = SVP64EXTRA(BI>>2)
        CR{SVCRf+srcstep} = CRbits
        testbit = CRbits[BI & 0b11]
    else if not SVRMmode.sz:
        SVSTATE.srcstep = new_srcstep
        exit # no branch testing
    else
        testbit = SVRMmode.SNZ
    # actual element test here
    cond_ok <- BO[0] | ¬(testbit ^ BO[1])
    # test for VL to be set (and exit)
    if ~cond_ok and VLSET
        if SVRMmode.VLI
            SVSTATE.VL = new_srcstep+1
        else
            SVSTATE.VL = new_srcstep
    SVSTATE.srcstep = new_srcstep
```
