# Evaluation

EULA released! looks good

* FP32 is converted to FP64. Requires SV to be active.
* FP16 needed
* FCVT between 16/32/64 needed
* c++11 atomics not very efficient
* no 16/48/64 opcodes, needs a shuffle of opcodes.  TODO investigate Power VLE
* needs escape sequencing (ISAMUX/NS)

# atomics

Single instruction on RV, and x86, but multiple on Power. Needs investigation, particularly as to why cache flush exists.

https://www.cl.cam.ac.uk/~pes20/cpp/cpp0xmappings.html

Hot loops contain significant instruction count, really need new c++11 atomics.  To be proposed as new extension because other OpenPower members will need them too

# FP16

Doesn't exist in Power, need to work out suitable opcodes, basically means duplicating the entire range of FP32/64 ops, symmetrically.

Usually done with a fmt field, 2 bit, last one is FP128

idea: rather than add dozens of new opcodes, add "repurposer" instructions that remap FP32 to 16/32/64/128 and FP64 likewise.  can also be done as C instruction, only needs 4 bits to specify.

# Escape Sequencing

Absolutely critical, also to have official endorsement from OpenPower Foundation.

This will allow extending ISA (see ISAMUX/NS) in a clean fashion

# Compressed, 48, 64, VBLOCK

TODO investigate Power VLE (Freescale doc Ref 314-68105)

Under Esc Seq, move mulli, twi, tdi out of major OP000 then use the entire row, 2 bits instead of 3.

* OP 000-000 and 000-001 for 16 bit compressed, 11 bit instructions
* OP 000-010 and 000-011 for 48 bit. 11 bits for SVP P48
* OP 000-100 and 000-201 for 64 bit. 11 bits for SVP P64
* OP 000-110 and 000-111 for VBLOCK. 11 bits available.

# Compressed 16

Only 11 bits. Idea: have "pages" where one instruction selects the page number. It also specifies for how long that page is activated (terminated on a branch)

The length to be a maximum of 4 bits, where 0b1111 indicates "permanently active".

Perhaps split OP000-000 and OP000-001 so that 2 pages can be active.

Store activation length in a CSR.

2nd idea: 11 bits can be used for extremely common operations, then length-encoding page selection for further ops, using the full 16 bit range and an entirely new encoding scheme. 1 bit specifies which of 2 pages was selected?

3rd idea: "stack" mechanism. Allow subpages like a stack, to page in new pages.

3 bits for subpage number. 4 bits for length, gives 7 bits. 4x7 is 28, then 3 bits can be used to specify "stack depth".

Requirements are to have one instruction in each subpage which resets all the way back to PowerISA default. The other is a "back up stack by 1".

## Branches

Branches are fine as it is up to the compiler to decide whether to let the countdown run out.

This is all a software / compiler / ABI issue.

## Function calls.

Storing and restoring the state of the page/subpage CSR should be done by the caller. Or, again, let the countdowns run out.

If certain alternative configs are expected, they are part of the function ABI which must be spec'd.

All of this is a software issue (compiler / ABI).

# RISCV userspace

Dual ISA, RV userspace only. Requires PowerISA to be able to context-switch RV registers and CSRs.

the exception entry point:
https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/powerpc/kernel/exceptions-64s.S?h=v5.4-rc5#n409

the rest of the context switch code is in a different file:
https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/powerpc/kernel/entry_64.S?h=v5.4-rc5#n589
