# Proposal to harmonise RV Vector spec with Andes Packed SIMD ("Harmonised" RVP)

##### MVL, setvl instruction & VL CSR work as per RV Vector spec.

##### VLD and VST are supported

RVP implementations may choose to load/store to/from Integer register file (rather than from a dedicated Vector register file).

* Thus, RVP implementations have a choice of providing a dedicated Vector register file, or sharing the integer register file, but not both  simultaneously.  (Supporting both would need a CSR mode switch bit).
* Mapping of v0-31 <-> r0-31 **is fixed** at 1:1.  (An exception may be made to map v1 to r5, as otherwise may clash with procedure linkage).
* VLD and VST in this case will have similar behaviour to LW/LD and SW/SD respectively, but only operate on up to VL elements (see point #4 below).   
* If integer register file is used for vector operations, any callee saved registers (r2-4, 8-9, 18-27) must be saved with RVI SW or SD instructions, before being used as vector registers (this register saving behaviour is harmless but redundant when RVP code is run on a machine with a dedicated vector reg file).

##### VLDX, VSTX, VLDS, VSTS are not supported in hardware
To keep RVP implementations simple, these instructions will trap, and may be implemented as software emulation

##### Default register "banks" and types

In the absence of an explicit VCFG setup, the vector registers (when shared with Integer register file) are to default into two “banks” as follows:

* v0-v15:    vectors with INT8 elements, split into 8 x signed (v0-v7) & 8 x unsigned (v8-v15)
* v16-v29:  vectors with INT16 elements, split into 8 x signed (v16-v23) & 6 x unsigned (v24-v29)

Having the above default vector type configuration harmonises most of the Andes SIMD instruction set (which explicitly encodes INT8 vs INT16 vector types as separate instructions).  The main change from the Andes SIMD proposal is that instructions are restricted to 14 registers of each vector element type (with element size explicitly encoded in the most significant bit of the 5 bit register specifier fields).

Notes:

* To preserve forward RVV compatibility, programmers should still explicitly setup VDCFG to the above default vector types
* Essentially the same register allocation algorithm used for RVV can be used for RVP, except the algorithm should preferentially use temporary registers first, before using saved registers
* v30-v31 are reserved for 32 bit operations (see Section 2.3 of this document), and hence not part of the register bank of INT16 vectors.
* v0 is mapped to r1 (hardwired to zero), and v1 is used for predicate masks.  However, both can be considered INT8 vectors.

##### Default MVL

The default RVV MVL value (in absence of explicit VCFG setup) is to be MVL = 2 on RV32I machines and MVL = 4 on RV64I machines.
However, note RV32I registers can fit 4x INT8 elements.  To preserve Andes SIMD behaviour, all VOP instructions should still operate on all “unused” elements in the register, regardless of MVL.  (This is still compliant with the RVV spec, provided elements from VL..MVL-1 are set to zero).  VMEM instructions however will only operate on VL elements, and so where full Andes SIMD compliance is required (without RVV forward compatibility), LW/LD and SW/SD are to be used instead of VLD and VST.

##### Alternative register "banks" and alternative MVL

A programmer can configure VCFG with any mix of these alternative configurations:

*  v0-v31 are all INT 16, and MVL is same as for Default MVL above
*  v0-v31 are all INT 8 and MVL is 4 on RV32I and 8 on RV64I
*  A lesser number of registers (<v31) could be supported, eg. default is only v0-v29 defined.  (Accessing registers beyond maximum defined by VDCFG is to be legal, with a type of INT32 assumed.  However, this is not to affect the MVL, which is to be calculated based on INT8/INT16 vectors only)
*  With the above alternative configs, there can be any split between signed & unsigned.

The above are pure subsets of valid RVV VCFG configurations (and hence forward compatible between RVP and RVV, whilst also keeping RVP simple).  Other useful element types are fixed point fraction types and small integer(4 bit to 7 bit) elements. However these are omitted for now as they aren’t currently part of RVV spec, and the intention of this proposal is to harmonise the Andes SIMD instructions into a subset of RVV.

[[Comparative analysis Harmonised RVP vs Andes Packed SIMD ISA proposal]]

# Comparative analysis with Andes Packed ISA proposal

## 16-bit Arithmetic

| Andes Mnemonic           | 16-bit Instruction        | Harmonised RVP Equivalent |
| ------------------ | ------------------------- | ------------------- |
| ADD16 rt, ra, rb   | Add                       | VADD (r16 <= rt,ra,rb <= r29), mm=00|
| RADD16 rt, ra, rb  | Signed Halving add        | RADD (r16 <= rt,ra,rb <= r23), mm=00|
| URADD16 rt, ra, rb | Unsigned Halving add      | RADD (r24 <= rt,ra,rb <= r29), mm=00|
| KADD16 rt, ra, rb  | Signed Saturating add     | VADD (r16 <= rt,ra,rb <= r23), mm=01|
| UKADD16 rt, ra, rb | Unsigned Saturating add   | VADD (r24 <= rt,ra,rb <= r29), mm=01|
| SUB16 rt, ra, rb   | Subtract                  | VSUB (r16 <= rt,ra,rb <= r29), mm=00|
| RSUB16 rt, ra, rb  | Signed Halving sub        | RSUB (r16 <= rt,ra,rb <= r23), mm=00|
| URSUB16 rt, ra, rb | Unsigned Halving sub                | RSUB (r24 <= rt,ra,rb <= r29), mm=00|
| KSUB16 rt, ra, rb  | Signed Saturating sub               | VSUB (r16 <= rt,ra,rb <= r23), mm=01|
| UKSUB16 rt, ra, rb | Unsigned Saturating sub             | VSUB (r24 <= rt,ra,rb <= r29), mm=01|
| CRAS16 rt, ra, rb  | Cross Add & Sub                     | |
| RCRAS16 rt, ra, rb | Signed Halving Cross Add & Sub      | |
| URCRAS16 rt, ra, rb| Unsigned Halving Cross Add & Sub    | |
| KCRAS16 rt, ra, rb | Signed Saturating Cross Add & Sub   | |
| UKCRAS16 rt, ra, rb| Unsigned Saturating Cross Add & Sub | |
| CRSA16 rt, ra, rb  | Cross Sub & Add                     | |
| RCRSA16 rt, ra, rb | Signed Halving Cross Sub & Add      | |
| URCRSA16 rt, ra, rb| Unsigned Halving Cross Sub & Add    | |
| KCRSA16 rt, ra, rb | Signed Saturating Cross Sub & Add   | |
| UKCRSA16 rt, ra, rb| Unsigned Saturating Cross Sub & Add | |

## 8-bit Arithmetic

| Andes Mnemonic           | 8-bit Instruction        | Harmonised RVP Equivalent |
| ------------------ | ------------------------- | ------------------- |
| ADD8 rt, ra, rb    | Add                       | VADD (r2 <= rt,ra,rb <= r15), mm=00 |
| RADD8 rt, ra, rb   | Signed Halving add        | RADD (r2 <= rt,ra,rb <= r7), mm=00 |
| URADD8 rt, ra, rb  | Unsigned Halving add      | RADD (r8 <= rt,ra,rb <= r15), mm=00 |
| KADD8 rt, ra, rb   | Signed Saturating add     | VADD (r2 <= rt,ra,rb <= r7), mm=01 |
| UKADD8 rt, ra, rb  | Unsigned Saturating add   | VADD (r8 <= rt,ra,rb <= r15), mm=01 |
| SUB8 rt, ra, rb    | Subtract                  | VSUB (r2 <= rt,ra,rb <= r15), mm=00 |
| RSUB8 rt, ra, rb   | Signed Halving sub        | RSUB (r2 <= rt,ra,rb <= r7), mm=00 |
| URSUB8 rt, ra, rb  | Unsigned Halving sub      | RSUB (r8 <= rt,ra,rb <= r15), mm=00 |
| KSUB8 rt, ra, rb   | Signed Saturating sub        | VSUB (r2 <= rt,ra,rb <= r7), mm=01 |
| UKSUB8 rt, ra, rb  | Unsigned Saturating sub      | VSUB (r8 <= rt,ra,rb <= r15), mm=01 |

## 16-bit Shifts

SRA[I]16/SRL[I]16/SLL[I]16 to be mapped to VOP shift instructions in same manner as ADD16/SUB16

The “K” (Saturation) and “u” (Rounding) variants could be encoded using VOP’s mm field (mm=01 is saturated or rounded shift, mm=00 is standard VOP shift)

| Andes Mnemonic             | 16-bit Instruction         | Harmonised RVP Equivalent |
| ------------------   | -------------------------  | ------------------- |
| SRA16 rt, ra, rb     | Shift right arithmetic     | VSRA (r16 <= rt,ra,rb <= r29), mm=00|
| SRAI16 rt, ra, im    | Shift right arithmetic imm | VSRAI (r16 <= rt,ra <= r29), mm=00|
| SRA16.u rt, ra, rb   | Rounding Shift right arithmetic     | VSRA (r16 <= rt,ra,rb <= r29), mm=01|
| SRAI16.u rt, ra, im  | Rounding Shift right arithmetic imm | VSRAI (r16 <= rt,ra <= r29), mm=01|
| SRL16 rt, ra, rb     | Shift right logical        | VSRL (r16 <= rt,ra,rb <= r29), mm=00|
| SRLI16 rt, ra, im    | Shift right logical imm    | VSRLI (r16 <= rt,ra <= r29), mm=00|
| SRL16.u rt, ra, rb   | Rounding Shift right logical     | VSRL (r16 <= rt,ra,rb <= r29), mm=01|
| SRLI16.u rt, ra, im  | Rounding Shift right logical imm | VSLRI (r16 <= rt,ra <= r29), mm=01|
| SLL16 rt, ra, rb     | Shift left logical         | VSLL (r16 <= rt,ra,rb <= r29), mm=00|
| SLLI16 rt, ra, im    | Shift left logical imm     | VSLLI (r16 <= rt,ra <= r29), mm=00|
| KSLL16 rt, ra, rb    | Saturating Shift left logical       | VSLL (r16 <= rt,ra,rb <= r29), mm=01|
| KSLLI16 rt, ra, im   | Saturating Shift left logical imm   | VSLLI (r16 <= rt,ra <= r29), mm=01|
| KSLRA16 rt, ra, rb    | Saturating Shift left logical or Shift right arithmetic              ||
| KSLRA16.u rt, ra, rb  | Saturating Shift left logical or Rounding Shift right arithmetic     ||


## 8-bit Shifts

Andes SIMD Packed ISA omits 8 bit shifts, but these can be encoded in Harmonised RVP as follows:

| Andes Mnemonic             | 8-bit Instruction         | Harmonised RVP Equivalent |
| ------------------   | -------------------------  | ------------------- |
| n/a     | Shift right arithmetic     | VSRA (r2 <= rt,ra,rb <= r15), mm=00|
| n/a     | Shift right arithmetic imm | VSRAI (r2 <= rt,ra <= r15), mm=00|
| n/a     | Rounding Shift right arithmetic     | VSRA (r2 <= rt,ra,rb <= r15), mm=01|
| n/a     | Rounding Shift right arithmetic imm | VSRAI (r2 <= rt,ra <= r15), mm=01|
| n/a     | Shift right logical        | VSRL (r2 <= rt,ra,rb <= r15), mm=00|
| n/a     | Shift right logical imm    | VSRLI (r2 <= rt,ra <= r15), mm=00|
| n/a     | Rounding Shift right logical     | VSRL (r2 <= rt,ra,rb <= r15), mm=01|
| n/a     | Rounding Shift right logical imm | VSLRI (r2 <= rt,ra <= r15), mm=01|
| n/a     | Shift left logical         | VSLL (r2 <= rt,ra,rb <= r15), mm=00|
| n/a     | Shift left logical imm     | VSLLI (r2 <= rt,ra <= r15), mm=00|
| n/a     | Saturating Shift left logical       | VSLL (r2 <= rt,ra,rb <= r15), mm=01|
| n/a     | Saturating Shift left logical imm   | VSLLI (r2 <= rt,ra <= r15), mm=01|

