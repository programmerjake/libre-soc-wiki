# FP Accuracy proposal

TODO: complete writeup

* <http://lists.libre-riscv.org/pipermail/libre-riscv-dev/2019-August/002400.html>
* <http://lists.libre-riscv.org/pipermail/libre-riscv-dev/2019-August/002412.html>

Zfpacc: a proposal to allow implementations to dynamically set the bit-accuracy
of results, trading speed (reduced latency) for accuracy (higher latency).
IEE754 format is preserved: only ULP (Unit in Last Place) is permitted to be non-zero.

# Extension of FCSR

Zfpacc would use some of the the reserved bits of FCSR.  It would be treated
very similarly to how dynamic frm is treated.

frm is treated as follows:

* Floating-point operations use either a static rounding mode encoded
  in the instruction, or a dynamic rounding mode held in frm.
* Rounding modes are encoded as shown in Table 11.1 of the RISC-V ISA Spec
* A value of 111 in the instruction’s rm field selects the dynamic rounding
  mode held in frm. If frm is set to an invalid value (101–111),
  any subsequent attempt to execute a floating-point operation with a
  dynamic rounding mode will raise an illegal instruction exception.

If we wish to support up to 4 accuracy modes, that would require 2 'fam'
bits.  The Default would be IEEE754-compliant, encoded as 00.  This means
that all current hardware would be compliant with the default mode.

Unsupported modes cause a trap to allow emulation where traps are supported.
Emulation of unsupported modes would be required for UNIX platforms.
As with frm, an implementation may choose to support any permutation
of dynamic fam-instruction pairs. It will illegal-instruction trap upon
executing an unsupported fam-instruction pair.  The implementation can
then emulate the accuracy mode required.

If the bits are in FCSR, then the switch itself would be exposed to
user mode.  User-mode would not be able to detect emulation vs hardware
supported instructions, however (by design).  That would require some
platform-specific code.

Emulation of unsupported modes would be required for unix platforms.

TODO:

A mechanism for user mode code to detect which modes are emulated
(csr? syscall?) (if the supervisor decides to make the emulation visible)
that would allow user code to switch to faster software implementations
if it chooses to.

TODO:

Choose which accuracy modes are required

    Which accuracy modes should be included is a question outside of
    my expertise and would require a literature review of instruction
    frequency in key workloads, PPA analysis of simple and advanced
    implementations, etc.

TODO: reduced accuracy

    I don't see why Unix should be required to emulate some arbitrary
    reduced accuracy ML mode.  My guess would be that Unix Platform Spec
    requires support for IEEE, whereas arbitrary ML platform requires
    support for Mode XYZ.  Of course, implementations of either platform
    would be free to support any/all modes that they find valuable.
    Compiling for a specific platform means that support for required
    accuracy modes is guaranteed (and therefore does not need discovery
    sequences), while allowing portable code to execute discovery
    sequences to detect support for alternative accuracy modes.

# Dynamic accuracy CSR <a name="dynamic"></a>

FCSR to be modified to include accuracy bits:

| 31....11 | 10..8  | 7..5 | 4....0 |
| -------- | ------ | ---- | ------ |
| reserved | facc   | frm  | fflags |

The values for the field facc to include the following:

| facc  | mode    | description         |
| ----- | ------- | ------------------- |
| 0b00H | IEEE754 | correctly rounded   | 
| 0b01H | ULP<1   | Unit Last Place < 1 | 
| 0b10H | Vulkan  | Vulkan compliant    | 
| 0b11H | Appx    | Machine Learning    |

When bit 0 (H) of facc is set to zero, half-precision mode is disabled. When set, an automatic down conversion (FCVT) to half the instruction bitwidth (FP32 opcode would convert to FP16) on operands is performed, followed by the operation occuring at half precision, followed by automatic up conversion back to the instruction's bitwidth.

Note that the format of the operands and result remain the same for all opcodes. The only change is in the *accuracy* of the result, not its format.

Pseudocode for half accuracy mode:

    def fpadd32(op1, op2):
        if FCSR.facc.halfmode:
            op1 = fcvt32to16(op1)
            op2 = fcvt32to16(op2)
            result = fpadd32(op1, op2)
            return fcvt16to32(result)
         else:
            # TODO, reduced accuracy if requested
            return op1 + op2

## Discussion

maybe a solution would be to add an extra field to the fp control csr
to allow selecting one of several accurate or fast modes:

- machine-learning-mode: fast as possible
  (maybe need additional requirements such as monotonicity for atanh?)
- GPU-mode: accurate to within a few ULP
  (see Vulkan, OpenGL, and OpenCL specs for accuracy guidelines)
- almost-accurate-mode: accurate to <1 ULP
     (would 0.51 or some other value be better?)
- fully-accurate-mode: correctly rounded in all cases
- maybe more modes?

Question: should better accuracy than is requested be permitted? Example:
Ahmdahl-370 issues.

Comments:

    Yes, embedded systems typically can do with 12, 16 or 32 bit
    accuracy. Rarely does it require 64 bits. But the idea of making
    a low power 32 bit FPU/DSP that can accommodate 64 bits is already
    being done in other designs such as PIC etc I believe. For embedded
    graphics 16 bit is more than adequate. In fact, Cornell had a very
    innovative 18-bit floating point format described here (useful for
    FPGA designs with 18-bit DSPs):

    <https://people.ece.cornell.edu/land/courses/ece5760/FloatingPoint/index.html>

    A very interesting GPU using the 18-bit FPU is also described here:

    <https://people.ece.cornell.edu/land/courses/ece5760/FinalProjects/f2008/ap328_sjp45/website/hardwaredesign.html>

    There are also 8 and 9-bit floating point formats that could be useful

    <https://en.wikipedia.org/wiki/Minifloat>
