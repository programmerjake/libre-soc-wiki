# Decoder

<http://bugs.libre-riscv.org/show_bug.cgi?id=186>

The decoder is in charge of translating the POWER instruction stream into operations that can be handled by our backend. It will have an extra input bit, set via a MSR, that will switch on GPU instructions.

Source code: <https://git.libre-riscv.org/?p=soc.git;a=tree;f=src/soc/decoder;hb=HEAD>

# POWER

The decoder has been written in python, to parse straight CSV files and other information taken directly from the Power ISA Standards PDF files. This significantly reduces the possibility of manual transcription errors and greatly reduces code size.  Based on Anton Blanchard's excellent microwatt design, these tables are in [[openpower/isatables]] which includes links to download the csv files.

The top level decoder object recursively drops through progressive levels of case statement groups, covering additional portions of the incoming instruction bits.  More on this technique - for which python and nmigen were *specifically* and strategically chosen - is outlined here <http://lists.libre-riscv.org/pipermail/libre-riscv-dev/2020-March/004882.html>

## Link to Function Units

The Decoder (PowerDecode2) knows which registers are needed, however what
it does not know is:

* which Register file ports to connect to (this is defined by regspecs)
* the order of those regfile ports (again: defined by regspecs)

Neither do the Phase-aware Function Units (derived from MultiCompUnit)
themselves know anything about the PowerDecoder, and they certainly
do not know when a given instruction will need to tell *them* to read
RA, or RB.  For example: negation of RA only requires one operand,
where add RA, RB requires two.  Who tells whom that information, when
the ALU's job is simply to add, and the Decoder's job is simply to decode?

This is where a special function called "rdflags()" comes into play.
rdflags works closely in conjunction with regspecs and the PowerDecoder2,
in each Function Unit's "pipe\_data.py" file.  It defines the flags that
determine, from current instruction, whether the Function Unit actually
*wants* any given Register Read Ports activated or not.

That dynamically-determined information will then actively disable
(or allow) Register file Read requests (rd.req) on a per-port basis.

* [[architecture/regfile]]
* [CompUnits](https://git.libre-soc.org/?p=soc.git;a=blob;f=src/soc/fu/compunits/compunits.py;hb=HEAD)
* [ALU pipe_data.py specification](https://git.libre-soc.org/?p=soc.git;a=blob;f=src/soc/fu/alu/pipe_data.py;hb=HEAD)

## Fixed point instructions

 - addi, addis, mulli - fairly straightforward - extract registers and immediate and translate to the appropriate op
 - addic, addic., subfic - similar to above, but now carry needs to be saved somewhere
 - add[o][.], subf[o][.], adde\*, subfe\*, addze\*, neg\*, mullw\*, divw\* - These are more fun. They need to set the carry (if . is present) and overflow (if o is present) flags, as well as taking in the carry flag for the extended versions.
 - addex - uses the overflow flag as a carry in, and if CY is set to 1, sets overflow like it would carry.
 - cmp, cmpi - sets bits of the selected comparison result register based on whether the comparison result was greater than, less than, or equal to
 - andi., ori, andis., oris, xori, xoris - similar to above, though the and versions set the flags in CR0
 - and\*, or\*, xor\*, nand\*, eqv\*, andc\*, orc\* - similar to the register-register arithmetic instructions above


