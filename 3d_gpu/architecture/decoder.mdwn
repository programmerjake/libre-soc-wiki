# Decoder

<http://bugs.libre-riscv.org/show_bug.cgi?id=186>

The decoder is in charge of translating the RISCV or POWER instruction stream into operations that can be handled by our backend. It will have an extra input bit, set via a MSR that will switch which architecture it treats an instruction as.

Source code: <https://git.libre-riscv.org/?p=soc.git;a=tree;f=src/soc/decoder;hb=HEAD>

# POWER

The decoder has been written in python, to parse straight CSV files and other information taken directly from the Power ISA Standards PDF files. This significantly reduces the possibility of manual transcription errors and greatly reduces code size.  Based on Anton Blanchard's excellent microwatt design, these tables are in [[openpower/isatables]] which includes links to download the csv files.

The top level decoder object recursively drops through progressive levels of case statement groups, covering additional portions of the incoming instruction bits.  More on this technique - for which python and nmigen were *specifically* and strategically chosen - is outlined here <http://lists.libre-riscv.org/pipermail/libre-riscv-dev/2020-March/004882.html>

## Fixed point instructions

 - `addi`, `addis`, `mulli` - fairly straightforward - extract registers and immediate and translate to the appropriate op
 - `addic`, `addic.`, `subfic` - similar to above, but now carry needs to be saved somewhere
 - `add[o][.]`, `subf[o][.]`, `adde*`, `subfe*`, `addze*`, `neg*`, `mullw*`, `divw*` - These are more fun. They need to set the carry (if `.` is present) and overflow (if `o` is present) flags, as well as taking in the carry flag for the `e`xtended versions.
 - `addex` - uses the overflow flag as a carry in, and if `CY` is set to 1, sets overflow like it would carry.
 - `cmp`, `cmpi` - sets bits of the selected comparison result register based on whether the comparison result was greater than, less than, or equal to
 - `andi.`, `ori`, `andis.`, `oris`, `xori`, `xoris` - similar to above, though the `and` versions set the flags in `CR0`
 - `and*`, `or*`, `xor*`, `nand*`, `eqv*`, `andc*`, `orc*` - similar to the register-register arithmetic instructions above


# RISCV

To save time, using minerva will help enormously
<https://github.com/lambdaconcept/minerva>
