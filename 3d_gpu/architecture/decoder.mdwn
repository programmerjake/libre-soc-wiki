# Decoder

The decoder is in charge of translating the RISCV or POWER instruction stream into operations that can be handled by our backend. It will have an extra input bit, set via a MSR that will switch which architecture it treats an instruction as.

Source code: <https://git.libre-riscv.org/?p=soc.git;a=tree;f=src/soc/decoder;hb=HEAD>

## POWER

### Fixed point instructions
 - `addi`, `addis`, `mulli` - fairly straightforward - extract registers and immediate and translate to the appropriate op
 - `addic`, `addic.`, `subfic` - similar to above, but now carry needs to be saved somewhere
 - `add[o][.]`, `subf[o][.]`, `adde*`, `subfe*`, `addze*`, `neg*`, `mullw*`, `divw*` - These are more fun. They need to set the carry (if `.` is present) and overflow (if `o` is present) flags, as well as taking in the carry flag for the `e`xtended versions.
 - `addex` - uses the overflow flag as a carry in, and if `CY` is set to 1, sets overflow like it would carry.
 - `cmp`, `cmpi` - sets bits of the selected comparison result register based on whether the comparison result was greater than, less than, or equal to
 - `andi.`, `ori`, `andis.`, `oris`, `xori`, `xoris` - similar to above, though the `and` versions set the flags in `CR0`
 - `and*`, `or*`, `xor*`, `nand*`, `eqv*`, `andc*`, `orc*` - similar to the register-register arithmetic instructions above



## RISCV
