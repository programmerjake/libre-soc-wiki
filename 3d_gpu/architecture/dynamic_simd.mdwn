# Dynamic Partitioned SIMD

The Dynamic Partitioned SIMD Signal is effectively a parallelisation
of nmigen's Signal.  It is expected to work transparently as if it was
a nmigen Signal, in every way, as a full peer of a nmigen Signal, with
no requirement on the part of the developer to even know that it is
performing parallel dynamically-partitioned operations.

nmigen 32-bit Signal:

    a        : .... .... .... .... (32 bits, illustrated as 4x8)

Dynamically-partitioned 32-bit Signal subdivided into four 8-bit
sections, by 3 partition bits:

    partition:     P    P    P     (3 bits)
    a        : .... .... .... .... (32 bits, illustrated as 4x8)
    exp-a    : ....P....P....P.... (32+3 bits, P=0 if no partition)

Each partitioned section shall act as an independent Signal where the **partitioning is dynamic at runtime** and may subdivide the above example
into all 8 possible combinations of the 3 Partition bits:

    exp-a    : ....0....0....0.... 1x 32-bit
    exp-a    : ....0....0....1.... 1x 24-bit plus 1x 8-bit
    exp-a    : ....0....1....0.... 2x 16-bit
    ...
    ...
    exp-a    : ....1....1....0.... 2x 8-bit, 1x 16-bit
    exp-a    : ....1....1....1.... 4x 8-bit


Links:

* <https://bugs.libre-soc.org/show_bug.cgi?id=458> m.If/Switch 
* <https://bugs.libre-soc.org/show_bug.cgi?id=115> top level SIMD
* <https://bugs.libre-soc.org/show_bug.cgi?id=707> Limited Cat
* <https://bugs.libre-soc.org/show_bug.cgi?id=594> RFC for nmigen integration
* <https://bugs.libre-soc.org/show_bug.cgi?id=565> Formal proof of PartitionedSignal
* <https://bugs.libre-soc.org/show_bug.cgi?id=596> Formal proof of PartitionedSignal nmigen interaction


To save hugely on gate count the normal practice of having separate scalar ALUs and separate SIMD ALUs is not followed.

Instead a suite of "partition points" identical in fashion to the Aspex Microelectronics ASP (Array-String-Architecture) architecture is deployed.

Basic principle: when all partition gates are open the ALU is subdivided into isolated and independent 8 bit SIMD ALUs.  Whenever any one gate is opened, the relevant 8 bit "part-results" are chained together in a downstream cascade to create 16 bit, 32 bit, 64 bit and 128 bit compound results.

Pages below describe the basic features of each and track the relevant bugreports.

* [[dynamic_simd/eq]]
* [[dynamic_simd/gt]]
* [[dynamic_simd/add]]
* [[dynamic_simd/cat]] - limited capability
* [[dynamic_simd/mul]]
* [[dynamic_simd/shift]]
* [[dynamic_simd/logicops]] some all xor

# Integration with nmigen

Dynamic partitioning of signals is not enough on its own. Normal nmigen programs involve conditional decisions, that means if statements and switch statements. 

With the PartitionedSignal class, basic operations such as `x + y` are functional, producing results 1x64 bit, or 2x32 or 4x16 or 8x8 or anywhere in between, but what about control and decisions? Here is the "normal" way in which SIMD decisions are performed:

    if partitions == 1x64
         with m.If(x > y):
              do something
    elif partitions == 2x32:
         with m.If(x[0:31] > y[0:31]):
              do something on 1st half
         elif ...
    elif ...
    # many more lines of repeated laborious hand written
    # SIMD nonsense all exactly the same except for the
    # for loop and sizes.

Clearly this is a total unmaintainable nightmare of worthless crud which, if continued throughout a large project with 40,000 lines of code when written without SIMD, would completely destroy all chances of that project being successful by turning 40,000 lines into 400,000 lines of unreadable spaghetti.

A much more intelligent approach is needed. What we actually want is:

    with m.If(x > y): # do a partitioned compare here
         do something dynamic here

where behind the scenes the above laborious for-loops (conceptually) are created, hidden, looking to all intents and purposes that this is exactly like any other nmigen Signal.

This means that nmigen needs to "understand" the partitioning, in m.If, m.Else and m.Switch, at the bare minimum.

Analysis of the internals of nmigen shows that m.If, m.Else and m.Switch are all redirected to `Value.cases`.  Within that function Mux and other "global" functions (similar to python operator functions).  The hypothesis is therefore proposed that if `Value.mux` is added in an identical way to how `operator.add` calls `__add__` this may turn out to be all that (or most of what) is needed.
