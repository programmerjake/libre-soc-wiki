# Dynamic Partitioned SIMD

The Dynamic Partitioned SIMD Signal is effectively a parallelisation
of nmigen's Signal.  It is expected to work transparently as if it was
a nmigen Signal, in every way, as a full peer of a nmigen Signal, with
no requirement on the part of the developer to even know that it is
performing parallel dynamically-partitioned operations.

nmigen 32-bit Signal:

    a        : .... .... .... .... (32 bits, illustrated as 4x8)

Dynamically-partitioned 32-bit Signal subdivided into four 8-bit
sections, by 3 partition bits:

    partition:     P    P    P     (3 bits)
    a        : .... .... .... .... (32 bits, illustrated as 4x8)
    exp-a    : ....P....P....P.... (32+3 bits, P=0 if no partition)

Each partitioned section shall act as an independent Signal where the **partitioning is dynamic at runtime** and may subdivide the above example
into all 8 possible combinations of the 3 Partition bits:

    exp-a    : ....0....0....0.... 1x 32-bit
    exp-a    : ....0....0....1.... 1x 24-bit plus 1x 8-bit
    exp-a    : ....0....1....0.... 2x 16-bit
    ...
    ...
    exp-a    : ....1....1....0.... 2x 8-bit, 1x 16-bit
    exp-a    : ....1....1....1.... 4x 8-bit

A simple example, a "min" function:

    # declare x, y and out as 16-bit scalar Signals
    x = Signal(16)
    y = Signal(16)
    out = Signal(16)

    # compare x against y and set output accordingly
    with m.If(x < y):
        comb += out.eq(x)
    with m.Else():
        comb += out.eq(y)

This is very straightforward and obvious, that the 16-bit output is the
lesser of the x and y inputs.  We require the exact same obviousness
and under no circumstances any change of any kind to any nmigen language
construct:

    # a mask of length 3 indicates a desire to partition Signals at
    # 3 points into 4 equally-spaced SIMD "partitions".
    mask = Signal(3)
    # x y and out are all 16-bit so are subdivided at:
    # |      mask[0]     mask[1]     mask[3]         |
    # |  0-3    |    4-7    |   8-11    |   12-15    |

    x = PartitionedSignal(mask, 16)    # identical except for mask
    y = PartitionedSignal(mask, 16)    # identical except for mask
    out = PartitionedSignal(mask, 16)  # identical except for mask

    # all code here is required to be absolutely identical to the
    # scalar case, and identical in nmigen language behaviour in
    # every way.  no changes to the nmigen language or its use
    # are permitted

    with m.If(x < y):
        comb += out.eq(x)
    with m.Else():
        comb += out.eq(y)

The purpose of PartitionedSignal is therefore to provide full 100%
transparent SIMD run-time dynamic behaviour as far as end-usage is
concerned.

The alternative is absolutely awful and completely unacceptable
for both maintenance cost and development cost:

    # declare x, y and out as 16-bit scalar Signals
    x = Signal(16)
    y = Signal(16)
    out = Signal(16)

    # start an absolutely awful unmaintainable duplication of
    # SIMD behaviour.
    with m.If(mask == 0b111): # 1x 16-bit
       # compare x against y and set output accordingly
       with m.If(x < y):
           comb += out.eq(x)
       with m.Else():
           comb += out.eq(y)
    with m.ElIf(mask == 0b101): # 2x 8-bit
       for i in range(2):
           xh = x[i*8:(i+1)*8]
           yh = y[i*8:(i+1)*8]
           outh = out[i*8:(i+1)*8]
           # compare halves of x against halves y and set
           # halves of output accordingly
           with m.If(xh < yh):
               comb += outh.eq(xh)
           with m.Else():
               comb += outh.eq(yh)
    with m.ElIf(mask == 0b000): # 4x 4-bit
        ....
    with m.ElIf(mask == 0b100): # 1x 8-bit followed by 2x 4-bit
        ....
    with m.ElIf(....)
        ....
    with m.ElIf(....)
        ....
    with m.ElIf(....)
        ....




# Links

* <https://bugs.libre-soc.org/show_bug.cgi?id=458> m.If/Switch 
* <https://bugs.libre-soc.org/show_bug.cgi?id=115> top level SIMD
* <https://bugs.libre-soc.org/show_bug.cgi?id=707> Limited Cat
* <https://bugs.libre-soc.org/show_bug.cgi?id=594> RFC for nmigen integration
* <https://bugs.libre-soc.org/show_bug.cgi?id=565> Formal proof of PartitionedSignal
* <https://bugs.libre-soc.org/show_bug.cgi?id=596> Formal proof of PartitionedSignal nmigen interaction
* <https://bugs.libre-soc.org/show_bug.cgi?id=713> Partition-context-sensitive length adjustment

# Rationale / Introduction

To save hugely on gate count the normal practice of having separate scalar ALUs and separate SIMD ALUs is not followed.

Instead a suite of "partition points" identical in fashion to the Aspex Microelectronics ASP (Array-String-Architecture) architecture is deployed.

Basic principle: when all partition gates are open the ALU is subdivided into isolated and independent 8 bit SIMD ALUs.  Whenever any one gate is opened, the relevant 8 bit "part-results" are chained together in a downstream cascade to create 16 bit, 32 bit, 64 bit and 128 bit compound results.

Pages below describe the basic features of each and track the relevant bugreports.

* [[dynamic_simd/eq]] aka `__eq__` not to be confused with nmigen eq
* [[dynamic_simd/assign]] nmigen eq (assignment)
* [[dynamic_simd/gt]]
* [[dynamic_simd/add]]
* [[dynamic_simd/cat]] - limited capability
* [[dynamic_simd/mul]]
* [[dynamic_simd/shift]]
* [[dynamic_simd/logicops]] some all xor

# Integration with nmigen

Dynamic partitioning of signals is not enough on its own. Normal nmigen programs involve conditional decisions, that means if statements and switch statements. 

With the PartitionedSignal class, basic operations such as `x + y` are functional, producing results 1x64 bit, or 2x32 or 4x16 or 8x8 or anywhere in between, but what about control and decisions? Here is the "normal" way in which SIMD decisions are performed:

    if partitions == 1x64
         with m.If(x > y):
              do something
    elif partitions == 2x32:
         with m.If(x[0:31] > y[0:31]):
              do something on 1st half
         elif ...
    elif ...
    # many more lines of repeated laborious hand written
    # SIMD nonsense all exactly the same except for the
    # for loop and sizes.

Clearly this is a total unmaintainable nightmare of worthless crud which, if continued throughout a large project with 40,000 lines of code when written without SIMD, would completely destroy all chances of that project being successful by turning 40,000 lines into 400,000 lines of unreadable spaghetti.

A much more intelligent approach is needed. What we actually want is:

    with m.If(x > y): # do a partitioned compare here
         do something dynamic here

where behind the scenes the above laborious for-loops (conceptually) are created, hidden, looking to all intents and purposes that this is exactly like any other nmigen Signal.

This means that nmigen needs to "understand" the partitioning, in m.If, m.Else and m.Switch, at the bare minimum.

Analysis of the internals of nmigen shows that m.If, m.Else and m.Switch are all redirected to ast.py `Switch`.  Within that function Mux and other "global" functions (similar to python operator functions).  The hypothesis is therefore proposed that if `Value.mux` is added in an identical way to how `operator.add` calls `__add__` this may turn out to be all that (or most of what) is needed.

<https://github.com/nmigen/nmigen/blob/59ef6e6a1c4e389a41148554f2dd492328820ecd/nmigen/hdl/dsl.py#L447>

m.If and m.Else work by constructing a series of Switch cases, each case test being one of "--1---" or "-----1-" where the binary tests themselves are concatenated together as the "Switch" statement.  With switch statements being order-dependent, the first match will succeed which will stop subsequent "Else" or "Elif" statements from being executed.

For a parallel variant each partition column may be assumed to be independent. A mask of 3 bits subdivides Signals down into four separate partitions.  Therefore what was previously a single-bit binary test is, just like for Partitioned Mux, actually four separate and distinct partition-column-specific single-bit binary tests.

Therefore, a Parallel Switch statement is as simple as taking the relevant column of each Switch case and creating one independent Switch per Partition column.  Take the following example:

     mask = Signal(3) # creates four partitions
     a = PartitionedSignal(mask, 4) # creates a 4-bit partitioned signal
     b = PartitionedSignal(mask, 4) # likewise
     c = PartitionedSignal(mask, 32)
     d = PartitionedSignal(mask, 32)
     o = PartitionedSignal(mask, 32)

     with m.If(a):
         comb += o.eq(c)
     with m.Elif(b):
         comb += o.eq(d)

If these were ordinary Signals, they would be translated to a Switch where:

* if_tests would be Cat(a, b) i.e. a 2 bit quantity
* cases would be (quantity 2) "1-" and "-1" in order to match
  against the first binary test bit of Cat(a, b) and the second,
  respectively.
* the first case would be "1-" to activate `o.eq(c)
* the second case would be "-1" to activate o.eq(d)

A parallel variant may thus perform a for-loop, creating four
**independent** Switches:

* take a[0] and b[0] and Cat them together `Cat(a[0], b[0])`
* take the output of each case result `o[0].eq[c[0])` and
  so on
* create the first independent Switch
* take a[1] and b[1] etc.

There are several ways in which the parts of each case, when
activated, can be split up: temporary Signals, analysing
the AST, or using PartitionedMux.
