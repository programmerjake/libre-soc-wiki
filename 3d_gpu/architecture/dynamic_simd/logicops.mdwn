# Logic boolean operations

Links

* <https://bugs.libre-soc.org/show_bug.cgi?id=176>
* <https://bugs.libre-soc.org/show_bug.cgi?id=549>

These are not the same as bitwise operations equivalent to:

     for i in range(64):
         result[i] = a[i] or b[i]

they are instead SIMD versions of:

     result = 0 # initial value (single bit)
     for i in range(64):
         result = result or a[i]

# bool (some operator) as an example

instead of the above single 64 bit bool result, dynamic partitioned SIMD must return a batch of results.   if the subdivision is 2x32 it is:

     result[0] = 0 # initial value for low word
     result[1] = 0 # initial value for hi word
     for i in range(32):
         result[0] = result[0] or a[i]
         result[1] = result[1] or a[i+32]

and likewise by the time 8x8 is reached:

     for j in range(8):
         result[j] = 0 # initial value for each byte
         for i in range(8):
             result[j] = result[j] or a[i+j*8]

now the question becomes: what to do when the Signal is dynamically partitionable? how do we merge all of the combinations, 1x64 2x32 4x16 8x8 into the same statically-allocated hardware?

the first thing is to define some conventions, that the answer (result) will always be 8 bit (not 1 bit) and that, rather than just one bit being set if some are set, all 8 bits are clear or all 8 bits are set.

     if result[0]:       # bit 0 true?
         result[1:7] = 1 # then set the remaining 7

likewise, when configured as 2x32 the result is subdivided into two 4 bit halves: the first half is all zero if all the first 32 bits are zero, and all ones if any one bit in the first 32 bits are set.

     result[0] = 0 # initial value for low word
     result[4] = 0 # initial value for hi word
     for i in range(32):
         result[0] = result[0] or a[i]
         result[4] = result[4] or a[i+32]
     if result[0]:
         result[1:3] = 1
     if result[4]:
         result[5:7] = 1

thus we have a convention where the result is *also a partitioned signal*, and can be reconfigured to return 1x boolean yes/no, 2x boolean yes/no, 4x boolean yes/no or up to 8 independent yes/no boolean values.

the second observation then is that, actually, just like the other partitioned operations, it may be possible to "construct" the longer results from the 8x8 ones, based on whether the partition gates are open or closed.

# Boolean truth table for Partitioned XOR

Exactly the same as for eq, instead the "xor" operator for example is the amalgamation of 4 partial results, x0 to x3.

     x0 = input[0:7].xor()
     x1 = input[8:15].xor()
     x2 = input[16:23].xor()
     x3 = input[24:31].xor()

table showing how to combine x0-3 based on partitions p0-2 to produce result o0-3

[[!table  data="""
p2p1p0 | o0       | o1 | o2 | o3
++++++ | ++++++++ | ++++++++ | ++++++++ | ++
0 0 0  | ^(x0-3)  | 0        | 0        | 0
0 0 1  | x0       | ^(x1-3)  | 0        | 0
0 1 0  | ^(x0-1)  | 0        | ^(x2-3)  | 0
0 1 1  | x0       | x1       | ^(x2-3)  | 0
1 0 0  | ^(x0-2)  | 0        | 0        | eq3
1 0 1  | x0       | ^(x1-2)  | 0        | eq3
1 1 0  | ^(x0-1)  | 0        | x2       | eq3
1 1 1  | x0       | x1       | x2       | eq3
"""]]

Example:

* when p2p1p0 == 101 this indicates that the output is to contain an XOR of the top 8 bits, the middle 16 bits, and the low 8 bits. this in a 4 bit result (o3o2o1o0)
* the top bit of the 4-bit answer contains x3, the middle 2 bits contain the XOR or x1 and x2, the first bit contains x0.
* therefore, the final result: the top bit contains the XOR of the input bits 24 to 31, the middle 2 bits contains the XOR of bits 8 to 15, the lowest bit contains the XOR of bits 0 to 7.
