# Logic boolean operations

Links

* <https://bugs.libre-soc.org/show_bug.cgi?id=176>
* <https://bugs.libre-soc.org/show_bug.cgi?id=549>

These are not the same as bitwise operations equivslent to:

     for i in range(64):
         result[i] = a[i] or b[i]

they are instead SIMD versions of:

     result = 0 # initial value (single bit)
     for i in range(64):
         result = result or a[i]

# bool (some operator) as an example

instead of the above single 64 bit bool result, dynamic partitioned SIMD must return a batch of results.   if the subdivision is 2x32 it is:

     result[0] = 0 # initial value for low word
     result[1] = 0 # initial value for hi word
     for i in range(32):
         result[0] = result[0] or a[i]
         result[1] = result[1] or a[i+32]

and likewise by the time 8x8 is reached:

     for j in range(8):
         result[j] = 0 # initial value for each byte
         for i in range(8):
             result[j] = result[j] or a[i+j*8]

now the question becomes: what to do when the Signal is dynamically partitionable? how do we merge all of the combinations, 1x64 2x32 4x16 8x8 into the same statically-allocated hardware?

the first thing is to define some conventions, that the answer (result) will always be 8 bit (not 1 bit) and that, rather than just one bit being set if some are set, all 8 bits are clear or all 8 bits are set.

     if result[0]:       # bit 0 true?
         result[1:7] = 1 # then set the remaining 7

likewise, when configured as 2x32 the result is subdivided into two 4 bit halves: the first half is all zero if all the first 32 bits are zero, and all ones if any one bit in the first 32 bits are set.

     result[0] = 0 # initial value for low word
     result[4] = 0 # initial value for hi word
     for i in range(32):
         result[0] = result[0] or a[i]
         result[4] = result[4] or a[i+32]
     if result[0]:
         result[1:3] = 1
     if result[4]:
         result[5:7] = 1

thus we have a convention where the result is *also a partitioned signal*, and can be reconfigured to return 1x boolean yes/no, 2x boolean yes/no, 4x boolean yes/no or up to 8 independent yes/no boolean values.

the second observation then is that, actually, just like the other partitioned operations, it may be possible to "construct" the longer results from the 8x8 ones, based on whether the partition gates are open or closed.

# Boolean truth table

Exactly the same as for eq, instead the "xor" operator for example is the amalgamation of 4 partial results, x0 to x3.

     x0 = input[0:7].xor()
     x1 = input[8:15].xor()
     x2 = input[16:23].xor()
     x3 = input[24:31].xor()

[[!table  data="""
p2p1p0 | o0       | o1 | o2 | o3
++++++ | ++++++++ | ++++++++ | ++++++++ | ++
0 0 0  | ^(x0-3)  | 0        | 0        | 0
0 0 1  | eq0      | &(eq1-3) | 0        | 0
0 1 0  | &(eq0-1) | 0        | &(eq2-3) | 0
0 1 1  | eq0      | eq1      | &(eq2-3) | 0
1 0 0  | &(eq0-2) | 0        | 0        | eq3
1 0 1  | eq0      | &(eq1-2) | 0        | eq3
1 1 0  | &(eq0-1) | 0        | eq2      | eq3
1 1 1  | eq0      | eq1      | eq2      | eq3
"""]]
