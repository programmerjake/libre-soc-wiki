# SimdShape

A logical extension of the nmigen `ast.Shape` concept, `SimdShape`
provides sufficient context to both define overrides for individual lengths
on a per-mask basis as well as sufficient information to "upcast"
back to a SimdSignal, in exactly the same way that c++ virtual base
class upcasting works when RTTI (Run Time Type Information) works.

By deriving from `ast.Shape` both `width` and `signed` are provided
already leaving the `SimdShape` class with the responsibility to
additionally define lengths for each mask basis. This is best illustrated
with an example.

The Libre-SOC IEEE754 ALUs need to be converted to SIMD Partitioning
but without massive disruptive code-duplication or intrusive explicit
coding as outlined in the worst of the techniques documented in
[[dynamic_simd]].  This in turn implies that Signals need to be declared
for both mantissa and exponent that **change width to non-power-of-two
sizes** depending on Partition Mask Context.

Mantissa:

* when the context is 1xFP64 the mantissa is 54 bits (excluding guard
  rounding and sticky)
* when the context is 2xFP32 there are **two** mantissas of 23 bits
* when the context is 4xFP16 there are **four** mantissas of 10 bits
* when the context is 4xBF16 there are four mantissas of 5 bits.

