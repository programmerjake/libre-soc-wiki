\documentclass[slidestop]{beamer}
\usepackage{beamerthemesplit}
\usepackage{graphics}
\usepackage{pstricks}

\title{Simple-V RISC-V Extension for Vectorisation and SIMD}
\author{Luke Kenneth Casson Leighton}


\begin{document}

\frame{
   \begin{center}
    \huge{Simple-V RISC-V Extension for Vectors and SIMD}\\
    \vspace{32pt}
    \Large{Flexible Vectorisation}\\
    \Large{(aka not so Simple-V?)}\\
    \vspace{24pt}
    \Large{[proposed for] Chennai 9th RISC-V Workshop}\\
    \vspace{24pt}
    \large{\today}
  \end{center}
}

\frame{\frametitle{Why another Vector Extension?}

 \begin{itemize}
   \item RVV very heavy-duty (excellent for supercomputing)\vspace{10pt}
   \item Simple-V abstracts parallelism (based on best of RVV)\vspace{10pt}
   \item Graded levels: hardware, hybrid or traps\vspace{10pt}
   \item Even Compressed instructions become vectorised\vspace{10pt}
  \end{itemize}
  What Simple-V is not:\vspace{10pt}
   \begin{itemize}
   \item A full supercomputer-level Vector Proposal\vspace{10pt}
   \item A replacement for RVV (designed to be augmented)\vspace{10pt}
  \end{itemize}
}

\frame{\frametitle{Quick refresher on SIMD}

 \begin{itemize}
   \item SIMD very easy to implement (and very seductive)\vspace{10pt}
   \item Parallelism is in the ALU\vspace{10pt}
   \item Zero-to-Negligeable impact for rest of core\vspace{10pt}
  \end{itemize}
  Where SIMD Goes Wrong:\vspace{10pt}
   \begin{itemize}
   \item See "SIMD instructions considered harmful"
   https://www.sigarch.org/simd-instructions-considered-harmful
   \item (Corner-cases alone are extremely complex)\vspace{10pt}
   \item O($N^{6}$) ISA opcode proliferation!\vspace{10pt}
  \end{itemize}
}

\frame{\frametitle{Quick refresher on RVV}

 \begin{itemize}
   \item Extremely powerful (extensible to 256 registers)\vspace{10pt}
   \item Supports polymorphism, several datatypes (inc. FP16)\vspace{10pt}
   \item Requires a separate Register File\vspace{10pt}
   \item Can be implemented as a separate pipeline\vspace{10pt}
  \end{itemize}
  However...\vspace{10pt}
   \begin{itemize}
   \item 98 percent opcode duplication with rest of RV (CLIP)\vspace{10pt}
   \item Extending RVV requires customisation\vspace{10pt}
  \end{itemize}
}


\frame{\frametitle{How is Parallelism abstracted?}

 \begin{itemize}
   \item Almost all opcodes removed in favour of implicit "typing"\vspace{10pt}
   \item Primarily at the Instruction issue phase (except SIMD)\vspace{10pt}
   \item Standard (and future, and custom) opcodes now parallel\vspace{10pt}
  \end{itemize}
  Notes:\vspace{10pt}
   \begin{itemize}
   \item LOAD/STORE (inc. C.LD and C.ST, LDX: everything)\vspace{10pt}
   \item All ALU ops (soft / hybrid / full HW, on per-op basis)\vspace{10pt}
   \item All branches become predication targets (C.FNE added)\vspace{10pt}
  \end{itemize}
}


\frame{\frametitle{Implementation Options}

 \begin{itemize}
   \item Absolute minimum: Exceptions (if CSRs indicate "V", trap)\vspace{10pt}
   \item Hardware loop, single-instruction issue\vspace{10pt}
   \item Hardware loop, parallel (multi-instruction) issue\vspace{10pt}
   \item Hardware loop, full parallel ALU (not recommended)\vspace{10pt}
  \end{itemize}
  Notes:\vspace{10pt}
  \begin{itemize}
   \item 4 (or more?) options above may be deployed on per-op basis
   \item Minimum MVL MUST be sufficient to cover regfile LD/ST
   \item OoO may split off 4+ single-instructions at a time
  \end{itemize}
}


\frame{\frametitle{How are SIMD Instructions Vectorised?}

 \begin{itemize}
   \item SIMD ALU(s) primarily unchanged\vspace{10pt}
   \item Predication is added to each SIMD element (NO ZEROING!)\vspace{10pt}
   \item End of Vector enables predication (NO ZEROING!)\vspace{10pt}
  \end{itemize}
  Considerations:\vspace{10pt}
   \begin{itemize}
   \item Many SIMD ALUs possible (parallel execution)\vspace{10pt}
   \item Very long SIMD ALUs could waste die area (short vectors)\vspace{10pt}
   \item Implementor free to choose (API remains the same)\vspace{10pt}
  \end{itemize}
}
% With multiple SIMD ALUs at for example 32-bit wide they can be used 
% to either issue 64-bit or 128-bit or 256-bit wide SIMD operations
% or they can be used to cover several operations on totally different
% vectors / registers.

\frame{\frametitle{What's the deal / juice / score?}

 \begin{itemize}
   \item Standard Register File(s) overloaded with "vector span"\vspace{10pt}
   \item Element width and type concepts remain same as RVV\vspace{10pt}
   \item CSRs are key-value tables (overlaps allowed)\vspace{10pt}
  \end{itemize}
  Key differences from RVV:\vspace{10pt}
   \begin{itemize}
   \item Predication in INT regs as a BIT field (max VL=XLEN)\vspace{10pt}
   \item Minimum VL must be Num Regs - 1 (all regs single LD/ST)\vspace{10pt}
   \item NO ZEROING: non-predicated elements are skipped\vspace{10pt}
  \end{itemize}
}


\frame{\frametitle{Why are overlaps allowed in Regfiles?}

 \begin{itemize}
   \item Same register(s) can have multiple "interpretations"\vspace{10pt}
   \item xBitManip plus SIMD plus xBitManip = Hi/Lo bitops\vspace{10pt}
   \item (32-bit GREV plus 4-wide 32-bit SIMD plus 32-bit GREV)\vspace{10pt}
   \item Same register(s) can be offset (no need for VSLIDE)\vspace{10pt}
  \end{itemize}
  Note:\vspace{10pt}
   \begin{itemize}
   \item xBitManip reduces O($N^{6}$) SIMD down to O($N^{3}$) \vspace{10pt}
   \item Hi-Performance: Macro-op fusion (more pipeline stages?)\vspace{10pt}
  \end{itemize}
}


\frame{\frametitle{Why no Zeroing (place zeros in non-predicated elements)?}

 \begin{itemize}
   \item Zeroing is an implementation optimisation favouring OoO\vspace{10pt}
   \item Simple implementations may skip non-predicated operations\vspace{10pt}
   \item Simple implementations explicitly have to destroy data\vspace{10pt}
   \item Complex implementations may use reg-renames to save power\vspace{10pt}
  \end{itemize}
  Considerations:\vspace{10pt}
  \begin{itemize}
   \item Complex not really impacted, Simple impacted a LOT
   \item Overlapping "Vectors" may issue overlapping ops
   \item Please don't use Vectors for "security" (use Sec-Ext)
  \end{itemize}
}
% with overlapping "vectors" - bearing in mind that "vectors" are
% just a remap onto the standard register file, if the top bits of
% predication are zero, and there happens to be a second vector
% that uses some of the same register file that happens to be
% predicated out, the second vector op may be issued *at the same time*
% if there are available parallel ALUs to do so.

\begin{frame}[fragile]
\frametitle{ADD pseudocode (or trap, or actual hardware loop)}

\begin{semiverbatim}
function op_add(rd, rs1, rs2, predr) # add not VADD!
  int i, id=0, irs1=0, irs2=0;
  for (i=0; i < MIN(VL, vectorlen[rd]); i++)
    if (ireg[predr] & 1<<i) # predication uses intregs
       ireg[rd+id] <= ireg[rs1+irs1] + ireg[rs2+irs2];
    if (reg_is_vectorised[rd]) \{ id += 1; \}
    if (reg_is_vectorised[rs1]) \{ irs1 += 1; \}
    if (reg_is_vectorised[rs2]) \{ irs2 += 1; \}
\end{semiverbatim}

  \begin{itemize}
   \item SIMD slightly more complex (case above is elwidth = default)
   \item Scalar-scalar and scalar-vector and vector-vector now all in one
   \item OoO may choose to push ADDs into instr. queue (v. busy!)
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Predication-Branch (or trap, or actual hardware loop)}

\begin{semiverbatim}
s1 = vectorlen[src1] > 1;
s2 = vectorlen[src2] > 1;
for (int i = 0; i < VL; ++i)
   preg[rs3] |= 1 << cmp(s1 ? reg[src1+i] : reg[src1],
                         s2 ? reg[src2+i] : reg[src2]);
\end{semiverbatim}

  \begin{itemize}
   \item SIMD slightly more complex (case above is elwidth = default)  
   \item If s1 and s2 both scalars, Standard branch occurs
   \item Predication stored in integer regfile as a bitfield
   \item Scalar-vector and vector-vector supported
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{LD/LD.S/LD.X (or trap, or actual hardware loop)}

\begin{semiverbatim}
if (unit-strided) stride = elsize;
else stride = areg[as2]; // constant-strided
for (int i = 0; i < VL; ++i)
  if (preg_enabled[rd] && ([!]preg[rd] & 1<<i))
    for (int j = 0; j < seglen+1; j++)
      if (vectorised[rs2]) offs = vreg[rs2][i]
      else offs = i*(seglen+1)*stride;
      vreg[rd+j][i] = mem[sreg[base] + offs + j*stride]
\end{semiverbatim}

  \begin{itemize}
   \item Again: SIMD slightly more complex
   \item rs2 vectorised taken to implicitly indicate LD.X
  \end{itemize}
\end{frame}


\frame{\frametitle{Opcodes, compared to RVV}

 \begin{itemize}
   \item All integer and FP opcodes all removed (no CLIP!)\vspace{10pt}
   \item VMPOP, VFIRST etc. all removed (use xBitManip)\vspace{10pt}
   \item VSLIDE, VEXTRACT, VINSERT removed (using regfile)\vspace{10pt}
   \item VSETVL, VGETVL, VSELECT stay\vspace{10pt}
   \item Issue: VCLIP is not in RV* (add with custom ext?)\vspace{10pt}
   \item Vector (or scalar-vector) use C.MV (MV is a pseudo-op)\vspace{10pt}
   \item VMERGE: twin predicated C.MVs (one inverted. macro-op'd)\vspace{10pt}
  \end{itemize}
}


\frame{\frametitle{Under consideration}

 \begin{itemize}
   \item Can VSELECT be removed (or overloaded onto xBitManip)?\vspace{10pt}
   \item Can CLIP be done as a CSR (mode, like elwidth)\vspace{10pt}
   \item SIMD saturation (etc.) also set as a mode?\vspace{10pt}
  \end{itemize}
}


\frame{\frametitle{slide}

 \begin{itemize}
   \item \vspace{10pt}
  \end{itemize}
  Considerations:\vspace{10pt}
  \begin{itemize}
   \item \vspace{10pt}
  \end{itemize}
}


\frame{\frametitle{slide}

 \begin{itemize}
   \item \vspace{10pt}
  \end{itemize}
  Considerations:\vspace{10pt}
  \begin{itemize}
   \item \vspace{10pt}
  \end{itemize}
}


\frame{\frametitle{Including a plot}
 \begin{center}
%  \includegraphics[height=2in]{dental.ps}\\
  {\bf \red Dental trajectories for 27 children:}
 \end{center}
}

\frame{\frametitle{Creating .pdf slides in WinEdt}

 \begin{itemize}
   \item LaTeX [Shift-Control-L]\vspace{10pt}
   \item dvi2pdf [click the button]\vspace{24pt}
  \end{itemize}
  To print 4 slides per page in acrobat click\vspace{10pt}
   \begin{itemize}
   \item File/print/properties\vspace{10pt}
   \item Change ``pages per sheet'' to 4\vspace{10pt}
  \end{itemize}
}

\frame{
  \begin{center}
    {\Huge \red The end}
  \end{center}
}


\end{document}
