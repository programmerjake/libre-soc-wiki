# SV setvl

sv.setvl allows optional setting of both MVL and of indirectly marking one of the scalar registers as being VL.

Unlike the majority of other CSRs, which contain status bits that change behaviour, VL is closely interlinked with the instructions it affects and often requires arithmetic interaction.
Thus it makes more sense to actually *use* one of the scalar registers *as* VL.

Format for Vector Configuration Instructions under OP-V major opcode:

| 31|30...20|19....15|14..12|11.7|6.....0| name       |
|---|-------|--------|------|----|-------|------------|
| 0 | VLMAX | rs1    | 111  | rd |1010111| sv.setvl   |
| 0 | VLMAX | 0 (x0) | 111  | rd |1010111| sv.setvl   |
| 1 | --    | --     | 111  | -- |1010111| *reserved* |


# pseudocode

    regs = [0u64; 128];
    vlval = 0;
    vl = rd;

    // instruction fields:
    rd = get_rd_field();
    rs1 = get_rs1_field();
    vlmax = get_immed_field();

    // handle illegal instruction decoding
    if vlmax > XLEN {
        trap()
    }

    // calculate VL
    if rs1 == 0 { // rs1 is x0
        vlval = vlmax
    } else {
        vlval = min(regs[rs1], vlmax)
    }

    // write rd
    if rd != 0 {
        // rd is not x0
        regs[rd] = vlval;
    }

# questions <a name="questions"></>

Moved to [[discussion]]

